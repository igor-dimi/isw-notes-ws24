[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Software Engineering Lecture Notes WS 24/25",
    "section": "",
    "text": "Preface\nLecture notes for the course “Software Engineering” at Heidelberg University WS24/25.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Chapters",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#chapters",
    "href": "intro.html#chapters",
    "title": "1  Introduction",
    "section": "",
    "text": "Introduction\nCommunication in a Project link\nRequirements Engineering (Communication with the Users) link\nDesign (Communication with Developers) link\nQuality Management link\nEvolution link\nSWE-Process (Summary and Project Management) link",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "02/02.html",
    "href": "02/02.html",
    "title": "2  Communication in a Project",
    "section": "",
    "text": "Following topics relate to and determine communication within a project:\n\nNumber of participants and their roles in the project\nType of the contractual relationship\nTeam Organization: The way developers communicate within the project\nCollaborative Coding\n\n\n2.0.1 Projects and Participants\nterms relating to project and process:\n\nprocess:\nproject\nprocess model:\n\ncharacteristics of a project:\n\nlimited time\ncreator\npurpose\nclient\nresults\nmeans and tools\norganization and planning\n\nparticipants:\n\nclient\nuser\nmanufacturer\n\n\n\n2.0.2 Contractual Relationship\nproject types:\n\nEP (Entwicklungsprojekt) -&gt; development project\nAP (Auftragsprojekt) -&gt; Commissioned Project\nEDP (EDV-Projekt, EDV = Elektronische Datenverarbeitung) -&gt; IT Project\nSP (Systemprojekt) -&gt; System Project\n\n\n\n2.0.3 Team Organization\ntypes of team organization:\n\nsingle person\n2-person team\nanarchic team\ndemocratic team\nhierarchical team\nchief-programmer team\nagile team\n\ntypes of secondary organization:\n\nfunctional\nproject-based\nmatrix\n\n\n\n2.0.4 Collaborative Coding\n\nPair programming\nDistributed development",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Communication in a Project</span>"
    ]
  },
  {
    "objectID": "03/03.html",
    "href": "03/03.html",
    "title": "3  Requirements Engineering",
    "section": "",
    "text": "requirements engineering can be understood as corresponding to the communication with the users / clients. Deals with the following topics\n\nIntroduction to communication with users/clients.\n\nClients and Requirements\nDescription and specification of requirements\nDefining Requirements Engineering\nOutcome of Requirements Engineering\nBenefit of specification\nComplexities of RE\n\nUsage modelling / description\n\nIntroductory Example\nIntroduction\nTasks, Roles, Persona\nDomain Data\nFunctions, UI-Structure\nGUI\n\nDocumentation Quality\n\nIntroduction and Templates\nCharacteristics and style guide\n\nUsability\nQuality assurance with the client\n\nacceptance test\nusability test\n\nQuality requirements\n\nMotivation\nQuality attributes\nQR-description\nQR-test\n\nUse-cases (not relevant to the exam)\n\nDescription of Uses Cases\nUse for system testing\n\nRE procedure\n\nIntroduction\nGathering requirements\nSpecificying requirements\n\n\n\n3.0.1 Communication with Users / Clients\n\nrequirements engineering:\n\ncollection of the requirements from the client\nspecification / formalization of the requirements\ntesting / examination of the requirements\nmanagement of the requirements\n\nrequirements engineering result:\n\ndocument:\n\ndescription using system functions\n\nprototype\n\nAdvantages and Uses of Specification:\nDisadvantages of a missing specification\nDifficulties related to RE:\n\n\n\n3.0.2 Usage Modelling\n\nTask-oriented Requirements Engineering:\n\nTask level: tasks, roles, persona\nDomain level: subtasks (as-is & to-be), domain data\ninteraction level: system functions, ui-structure\nsystem level: gui, screen-structure (virtual window)\n\n\nRoles, Persona, Tasks\n\n3.0.2.1 Roles, Persona\nUDC (User-centered design)\nRoles and Persona\n\nUser role:\nUser profile:\n\nHow are personae described:\n\nname\nbiographic facts: age, gender, etc\nknowledge and attitude with respect to the tasks and technology:\nneeds: main use-cases in which the user wants to apply the software -&gt; Tasks\nfrustrations:\nideal features:\n\n\n\n3.0.2.2 Tasks\nHow tasks are described:\n\nGoals\nDecisions\nCauses\nPriority\nExecution profile (frequency, continuity, complexity)\nPrecondition\nInfo-in (input)\nInfo-out (output)\nresources (means, participating roles)\n\nsub-tasks:\nPersona-task correspondence:\n\nneeds &lt;=&gt; sub-tasks =&gt; combination of system-functions\nfrustrations &lt;=&gt; problems in sub-tasks\nideal features &lt;=&gt; ideas, system functions\n\n\n\n3.0.2.3 Domain Data\nDomain data explain the terms used in the task descriptions.\nGoal: describe/model the entities of real world, including their relationships / associations to each other, in order to understand the tasks.\n\ndomain data describe entities that are relevant within the context of the sofwtare. They correspond to the terms used in the task description =&gt; independent from the software.\ndescribed with simple class diagrams =&gt; domain data diagram (no operations, no aggregation, no inheritence, only associations)\nsometimes glossary is sufficient.\n\nsometimes not sufficient, because there additional data necessary on the UI level =&gt; interaction data. (not relevant in our MMAP case)\n\n\n3.0.2.4 Functions & UI-Structure (Interaction Level)\nGoal: implementation of the User/Machine boundary with respect to the task descriptions.\nconsists of 2 parts:\n\nSystem functions: which functions are provided by the system?\nUI-Structure:\n\nin which context can the user call which functions,\nwhich data is available/visible in those contexts?\nhow are functionalities divided among the sub-parts?\n\n\n\n\n\n\n\n\nWarning\n\n\n\nUI-Structure is not GUI-structure, i.e. the concrete layout is not yet determined.\n\n\n\n3.0.2.4.1 System Functions\nhow is a system function described:\n\nname: nomenclature verb-object, describe what will be achieved on the user data (e.g. unlinkMovie =&gt; movie will be unlinked)\ninput:\n\ncontext (i.e. workspace) in which the SF accessible\n\nconcrete input: data that is gathered during the interaction with the user. Such data is not yet determined when the SF is first called on the GUI, but first provided by the user during the interaction.\noutput: changes of the UI\ndescription:\nexceptions: cancel/discard by the user\nrules:\nquality requirements:\nprecondition:\npostcondition:\n\n\n\n3.0.2.4.2 UI-Structure\nConsists of\n\nworkspaces:\n\nbundle related system functions and data similar to a class (but only from an abstract user point of view. Actual structure in code can be completely different)\nonly system functions that can be triggered by the user are listed\n\nnavigation links between workspaces\n\nUI-structure abstracts from a concrete screen-layout. Logical represents a logical view of the interaction structure.\n\n\n\n\n\n\nImportant\n\n\n\nUI-structure is created concurrently with the System functions, because their close interrelation. (Workspaces contain System functions and data)\n\n\n\n\n\n3.0.2.5 Design of System Functions and UI-Structure\n\nhow is the system function specification template filled in?\nhow are ui-structure decision made concurrently to SF specifications?\ninitial test considerations?\n\nThere’s still lots of wiggle room for specific design decisions.\nTODO:\n\n\n3.0.2.6 GUI\nGUI= concrete layout of the UI:\n\ndata representation\nfunction representation\nwindow structure\ndialogue description (how user controls the execution of functions)\n\nDesign principles:\n\nlaw of proximity\nlaw of closure\nlaw of good continuation\nlaw of similarity\n\nTypes of functions:\n\nsemantic functions: actual data manipulation in the system, e.g. save, open, calculate something etc\nhelp functions / auxillary functions: data manipulation on the screen, e.g. text size\nsearch\nnavigation\n\nHow functions are represented:\n\nbuttons\ncheckbox\nmenu-selection\nshortcut\nicon\nscroll-bar\ndrag-and-drop\n\nViews (Window / Screen): concrete version of Workspaces:\n\nhow is data represented\nhow are functions made available / represented\n\nDocumentation of a view: Virtual Window (Mock-up)\n\n\n\n3.0.3 Documentation Quality\nfollowing topics relate to it:\n\ndocument templates\nfeatures and sytle-guide\n\nmany docuemnts exist:\n\nSoftware context-design:\n\nproblem-description\ncontract\nacceptance test plan\n\nRequirements Engineering:\n\nClient-requirements\nUsage test plan\nSoftware specification\nSystem test plan\n\narchitectural specification:\n\narchitectural specification / definition\nsub-system specification\n\nDetailed design:\n\ncomponent specification\nintegration test plan\n\nImplementation:\n\nCode\nComponent test plan\n\n\nCommunication happens via / is facilitated by documents\n\n\n3.0.4 Usability",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "04/04.html",
    "href": "04/04.html",
    "title": "4  Design",
    "section": "",
    "text": "Desing can be understood as communication with and wthin the developers. Deals with the following topics:\n\nIntroduction to Modelling\nClass diagrams\nInteraction diagrams (sequence diagrams)\nState Diagrams\n\nUML State diagrams\nDialog models\n\nClass design with OOAD\n\nOOAD introduction\nOOAD: Analysis Class diagram\nOOAD: Design Class Diagram\n\nDesign Patterns\n\nIntroduction\nCreational patterns\nStructural patterns\nBehavioral patterns\n\nRationales (Communication of decisions)\nSummary of modelling techniques",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Design</span>"
    ]
  },
  {
    "objectID": "05/05.html",
    "href": "05/05.html",
    "title": "5  Quality Assurance",
    "section": "",
    "text": "Quality: Software satisfies the requirements\ntopics:\n\nIntroduction\nOrganizational quality assurance\nTesting:\n\nIntro\nTest-case specification\nBlack-box component testing\nWhite-box component testing\nSystem testing\nIntegration testing / overall-component testing\n\nStatic testing\n\nStatic Analysis\nMetrics\nInspection\n\nAnalytical Quality assurance at large",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Quality Assurance</span>"
    ]
  },
  {
    "objectID": "06/06.html",
    "href": "06/06.html",
    "title": "6  Evolution",
    "section": "",
    "text": "All activities that facilitate re-use and further development. (All activities that take place after the initial development phase)\ntopics:\n\nIntro\nArchitecture\nRe-use\nFurther development and change management\nDevOps & IT-Governence\nRe-engineering",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Evolution</span>"
    ]
  },
  {
    "objectID": "07/07.html",
    "href": "07/07.html",
    "title": "7  SWE Process & Project Management",
    "section": "",
    "text": "Making sure that the Software system is developed withing the time money constraints.\ntopics:\n\nProject management\nSWE-process models & methods",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>SWE Process & Project Management</span>"
    ]
  }
]
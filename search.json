[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Software Engineering Lecture Notes WS 24/25",
    "section": "",
    "text": "Preface\nLecture notes for the course “Software Engineering” at Heidelberg University WS24/25."
  },
  {
    "objectID": "intro.html#chapters",
    "href": "intro.html#chapters",
    "title": "1  Introduction",
    "section": "1.1 Chapters",
    "text": "1.1 Chapters\n\nIntroduction\nCommunication in a Project link\nRequirements Engineering (Communication with the Users) link\nDesign (Communication with Developers) link\nQuality Management link\nEvolution link\nSWE-Process (Summary and Project Management) link"
  },
  {
    "objectID": "02/02.html",
    "href": "02/02.html",
    "title": "2  Communication in a Project",
    "section": "",
    "text": "Following topics relate to and determine communication within a project:\n\nNumber of participants and their roles in the project\nType of the contractual relationship\nTeam Organization: The way developers communicate within the project\nCollaborative Coding\n\n\n2.0.1 Projects and Participants\nterms relating to project and process:\n\nprocess:\nproject\nprocess model:\n\ncharacteristics of a project:\n\nlimited time\ncreator\npurpose\nclient\nresults\nmeans and tools\norganization and planning\n\nparticipants:\n\nclient\nuser\nmanufacturer\n\n\n\n2.0.2 Contractual Relationship\nproject types:\n\nEP (Entwicklungsprojekt) -&gt; development project\nAP (Auftragsprojekt) -&gt; Commissioned Project\nEDP (EDV-Projekt, EDV = Elektronische Datenverarbeitung) -&gt; IT Project\nSP (Systemprojekt) -&gt; System Project\n\n\n\n2.0.3 Team Organization\ntypes of team organization:\n\nsingle person\n2-person team\nanarchic team\ndemocratic team\nhierarchical team\nchief-programmer team\nagile team\n\ntypes of secondary organization:\n\nfunctional\nproject-based\nmatrix\n\n\n\n2.0.4 Collaborative Coding\n\nPair programming\nDistributed development"
  },
  {
    "objectID": "03/03.html",
    "href": "03/03.html",
    "title": "3  Requirements Engineering",
    "section": "",
    "text": "requirements engineering can be understood as corresponding to the communication with the users / clients. Deals with the following topics\n\nIntroduction to communication with users/clients.\n\nClients and Requirements\nDescription and specification of requirements\nDefining Requirements Engineering\nOutcome of Requirements Engineering\nBenefit of specification\nComplexities of RE\n\nUsage modelling / description\n\nIntroductory Example\nIntroduction\nTasks, Roles, Persona\nDomain Data\nFunctions, UI-Structure\nGUI\n\nDocumentation Quality\n\nIntroduction and Templates\nCharacteristics and style guide\n\nUsability\nQuality assurance with the client\n\nacceptance test\nusability test\n\nQuality requirements\n\nMotivation\nQuality attributes\nQR-description\nQR-test\n\nUse-cases (not relevant to the exam)\n\nDescription of Uses Cases\nUse for system testing\n\nRE procedure\n\nIntroduction\nGathering requirements\nSpecificying requirements\n\n\n\n3.0.1 Communication with Users / Clients\n\nrequirements engineering:\n\ncollection of the requirements from the client\nspecification / formalization of the requirements\ntesting / examination of the requirements\nmanagement of the requirements\n\nrequirements engineering result:\n\ndocument:\n\ndescription using system functions\n\nprototype\n\nAdvantages and Uses of Specification:\nDisadvantages of a missing specification\nDifficulties related to RE:\n\n\n\n3.0.2 Usage Modelling\n\nTask-oriented Requirements Engineering:\n\nTask level: tasks, roles, persona\nDomain level: subtasks (as-is & to-be), domain data\ninteraction level: system functions, ui-structure\nsystem level: gui, screen-structure (virtual window)\n\n\nRoles, Persona, Tasks\n\n3.0.2.1 Roles, Persona\nUDC (User-centered design)\nRoles and Persona\n\nUser role:\nUser profile:\n\nHow are personae described:\n\nname\nbiographic facts: age, gender, etc\nknowledge and attitude with respect to the tasks and technology:\nneeds: main use-cases in which the user wants to apply the software -&gt; Tasks\nfrustrations:\nideal features:\n\n\n\n3.0.2.2 Tasks\nHow tasks are described:\n\nGoals\nDecisions\nCauses\nPriority\nExecution profile (frequency, continuity, complexity)\nPrecondition\nInfo-in (input)\nInfo-out (output)\nresources (means, participating roles)\n\nsub-tasks:\nPersona-task correspondence:\n\nneeds &lt;=&gt; sub-tasks =&gt; combination of system-functions\nfrustrations &lt;=&gt; problems in sub-tasks\nideal features &lt;=&gt; ideas, system functions\n\n\n\n3.0.2.3 Domain Data\nDomain data explain the terms used in the task descriptions.\nGoal: describe/model the entities of real world, including their relationships / associations to each other, in order to understand the tasks.\n\ndomain data describe entities that are relevant within the context of the sofwtare. They correspond to the terms used in the task description =&gt; independent from the software.\ndescribed with simple class diagrams =&gt; domain data diagram (no operations, no aggregation, no inheritence, only associations)\nsometimes glossary is sufficient.\n\nsometimes not sufficient, because there additional data necessary on the UI level =&gt; interaction data. (not relevant in our MMAP case)\n\n\n3.0.2.4 Functions & UI-Structure (Interaction Level)\nGoal: implementation of the User/Machine boundary with respect to the task descriptions.\nconsists of 2 parts:\n\nSystem functions: which functions are provided by the system?\nUI-Structure:\n\nin which context can the user call which functions,\nwhich data is available/visible in those contexts?\nhow are functionalities divided among the sub-parts?\n\n\n\n\n\n\n\n\nWarning\n\n\n\nUI-Structure is not GUI-structure, i.e. the concrete layout is not yet determined.\n\n\n\n3.0.2.4.1 System Functions\nhow is a system function described:\n\nname: nomenclature verb-object, describe what will be achieved on the user data (e.g. unlinkMovie =&gt; movie will be unlinked)\ninput:\n\ncontext (i.e. workspace) in which the SF accessible\n\nconcrete input: data that is gathered during the interaction with the user. Such data is not yet determined when the SF is first called on the GUI, but first provided by the user during the interaction.\noutput: changes of the UI\ndescription:\nexceptions: cancel/discard by the user\nrules:\nquality requirements:\nprecondition:\npostcondition:\n\n\n\n3.0.2.4.2 UI-Structure\nConsists of\n\nworkspaces:\n\nbundle related system functions and data similar to a class (but only from an abstract user point of view. Actual structure in code can be completely different)\nonly system functions that can be triggered by the user are listed\n\nnavigation links between workspaces\n\nUI-structure abstracts from a concrete screen-layout. Logical represents a logical view of the interaction structure.\n\n\n\n\n\n\nImportant\n\n\n\nUI-structure is created concurrently with the System functions, because their close interrelation. (Workspaces contain System functions and data)\n\n\n\n\n\n3.0.2.5 Design of System Functions and UI-Structure\n\nhow is the system function specification template filled in?\nhow are ui-structure decision made concurrently to SF specifications?\ninitial test considerations?\n\nThere’s still lots of wiggle room for specific design decisions.\nTODO:\n\n\n3.0.2.6 GUI\nGUI= concrete layout of the UI:\n\ndata representation\nfunction representation\nwindow structure\ndialogue description (how user controls the execution of functions)\n\nDesign principles:\n\nlaw of proximity\nlaw of closure\nlaw of good continuation\nlaw of similarity\n\nTypes of functions:\n\nsemantic functions: actual data manipulation in the system, e.g. save, open, calculate something etc\nhelp functions / auxillary functions: data manipulation on the screen, e.g. text size\nsearch\nnavigation\n\nHow functions are represented:\n\nbuttons\ncheckbox\nmenu-selection\nshortcut\nicon\nscroll-bar\ndrag-and-drop\n\nViews (Window / Screen): concrete version of Workspaces:\n\nhow is data represented\nhow are functions made available / represented\n\nDocumentation of a view: Virtual Window (Mock-up)\n\n\n\n3.0.3 Documentation Quality\nfollowing topics relate to it:\n\ndocument templates\nfeatures and sytle-guide\n\nmany documents exist:\n\nSoftware context-design:\n\nproblem-description\ncontract\nacceptance test plan\n\nRequirements Engineering:\n\nClient-requirements\nUsage test plan\nSoftware specification\nSystem test plan\n\narchitectural specification:\n\narchitectural specification / definition\nsub-system specification\n\nDetailed design:\n\ncomponent specification\nintegration test plan\n\nImplementation:\n\nCode\nComponent test plan\n\n\nCommunication happens via / is facilitated by documents\n\n\n3.0.4 Usability\nThe degree to which a product can be used efficiently and adequately for specific tasks / goals, in a specific usage context:\n\neffectivity\nefficiency\nsatisfaction\n\n7 interaction (dialogue) principles :\n\nTask appropriateness: no unnecessary repetitive actions must be taken bythe user\nSelf-descriptiveness: user knows what the actions achieve, what’s the input, output and the systems response.\nControllability: user can decide the order of the operations, can terminate the operation and resume at any given moment without loss.\nExpectation-conformity: system is consistent, confirms to users real-life experience and other software conventions\nError tolerance: even at the hands of an incorrect input the intended result can be achieved with minimum correction effort.\nUser engagement: system must be appealing and inviting and provide users a positive experience.\nLearnability: users are supported and guided during the learning of the software\n\n\n\n3.0.5 Quality Assurance with the Clients\n\nverification: whether the software being built confirms to the specifications derived from the requirements and whether the requierements documents meet quality standards\nvalidation: whether the specifications actually correspond to clients requirements \\(\\Rightarrow\\):\n\nusability test\nacceptance test\n\n\n\n3.0.5.1 Acceptance Test\n\nTests whether the client accepts the system \\(\\Rightarrow\\) validation.\nUses system tests provided by the client\nincludes particularly also usability tests.\ntests are carried out in the production environment (live system where the software is fully deployed and used by the clients)\n\n\n\n3.0.5.2 Usability Test\nA representative group of users from the target demographic of the product take part in the test to determine to what extent the usability criteria is met.\nConsists of:\n\nusers\nobservers\n\nhow:\n\ndevelop a test plan:\n\ngoal\ndescription of the problem\ndescription of the users\ntest design\nlist of tasks\ntest environment\nevaluation criteria\n\nprepare the test:\n\nrecruiting a representative group\nrecruiting observers\ndistribution and review of the test plan with the participants\nprepare scenarios\nprepare surveys: backgroung, pretest, posttest\nprepare test env\n\nexecute the test:\nanalyse the results\n\n\n\n\n3.0.6 Quality requirements\n\n3.0.6.1 Motivation\n\nfunctional requirements \\(\\Rightarrow\\) what?\n\ntasks\nsystem functions\ngui\n\nnon-functional requirements (NFR) \\(\\Rightarrow\\) how good?\n\nQuality of the system\n\nQR = quality requirements: describe product considerations\nQA = quality attributes\n\n\n\n3.0.6.2 Quality Attributes\nQA describe various types of software quality.\nCategories:\n\nQuality in Use: Direct validation with the users\n\nBeneficialness: how well are users supported\n\nusability\naccessibility\nsuitability\n\nfreedom from risk: general impact\nacceptability (how good is the system from the point of view of the user)\n\nsupport experience\ntrustworthiness\ncompliance (regulations, laws)\n\n\nSoftware Product Quality: verification (internally), validation (externally), continuously during the whole development process\n\nfunctional stability\n\nfunctional completeness\nfunctional correctness\nfunctional appropriateness (helpful)\n\nperformance efficiency\n\ntime behavior\nresource utilization\ncapacity\n\ncompatibility\n\nco-existence with other software\ninteroperability\n\ninteraction capability (usability)\n\nrecognizability\nlearnability\noperability\nuser error protection\nuser engagement\ninclusivity\nuser assistance\n\nreliability\n\nfaultlessness\navailability\nfault tolerance\nrecoverability\n\nsecurity\n\nconfidentiality\nintegrity\nnon-repudiation\naccountability\nauthenticity\n\nmaintainability\n\nmodularity\nreusability\nanalysability\nmodifiability\ntestability\n\nflexibility\n\nadaptability\nscalability\ninstallability\nreplaceability\n\nsafety\n\noperational constraint\nrisk identification\nfail safe\nhazard warning\nsafe integration\n\n\n\n\n\n3.0.6.3 Describing QR\n\nQR should be made as measurable and as concrete as possible.\nQR are defined in parallel with the FR with as much detail as possible, for all levels:\n\nTasks\nDomain data\nFunctions\nGUI\n\n\n\n\n3.0.6.4 Testing QR\n\nDifferent QA categories require different testing methods.\nUsually only possible at the level of system testing, especially acceptance testing.\nUsually conducted by acting out scenarios\n\n\n\n\n3.0.7 Use Cases\nSo far we described the requirements via:\n\n(Sub)-Tasks\nDomain Data\nRoles / Persona\nSystem functions\nInteraction data\nUI Structure\n\nAt the system level this is further refined via:\n\nconcrete views\ninteraction models\n\nBut this is only an indirect description of users interaction with the system.\nUse Cases describe the specifics of users interactions with the system, specifically the particular execution sequence of system function to complete a certain (sub-)task. Thus, they are derived from Tasks\nuse cases vs TORE:\n\nuse cases cover only a subset of TORE. Particularly\n\nNo domain data model\nNo UI-Structure (which SF & Data are available in which view, how do you navigate between views)\n\nUC integrate SF within the execution flow, in TORE SF are contained in the subtask description (although without the execution flow)\n\n\n3.0.7.1 Description of a UC\nExample: manage movie or performer ratings in MMAPP.\n\nName: Manage Rating\nActor: Person\nGoal: to rate movies or performers\nPrecondition: at least one movie exists. Depending on the current state wither A1 or A2 is the starting point:\n\nFlow of events:\n\nActor: A1) W0.1 Movie Master View … System: System shows the\n…\n\nRules:\nQuality requirements:\nData, System Functions:\nPostcondition:\n\n\n\n\n3.0.7.2 Use of System Tests\nScenario vs UC:\n\nScenario: a specific interaction flow\nUC: an abstract description of a set of scenarios\n\nA choice of a typical set of scenarios can be used as a template when creating a UC. On the other hand a UC can be validated by a subsequent creation of a set of test scenarios.\nWhat is a typical flow?\n\nnormal flow\ncoverage of branches / exceptions\ndealing with large input (stress test)\ndealing with complex execution flows (many functions are called)\n\n\n\n\n3.0.8 RE Procedure - Method of RE\nSo far we only concerned ourselves with describing the requirements. Here we explain how to gather and manage them.\n\n3.0.8.1 Introduction\nStakeholder (client) requirements: the requirements stipulated by the client to achieve a certain goal or solve a certain problem.\n\nrequirements are gathered\nrequirements are formulated / formalized in the specification\nspecifications are validated and verified\nspecifications are translated into a design\nthe design is implemented\nthe implementation is tested\nthe implementation is deployed to the clients\n\n\n\n3.0.8.2 Gathering Requirements\nwhat information should be gathered:\n\nprevious method to solve the problem\nproblems related to the previous method\ngoals for the new system / method to solve the problem\nsuccess criteria\nrough system architecture (how many components, distribution)\nrealistic solutions\nconsequences and risks\n\nhow it is gathered:\n\nobservation\nuser surveying\nethnographic studies\nuse cases\nworkshops\nobject oriented analysis\nentity relationship diagrams\nconceptual modelling\ndata flow diagram\nformal specification\nprototypes\nobservations of other products\nliterature research\nstudying standard software\n\nrequirements can also be gathered via user feedback\n\n\n3.0.8.3 Specifying Requirements\ncontents and types of requirement specification:\n\nfunctional requirements: how should the software support the users?\nnon-functional requirements:\n\nquality requirements: how well should the software support the users?\nedge conditions\n\nrationales: reasoning behind the decisions?\n\nrequirement specification is textual as well as schematic (UML, ER etc)\nThere are two types of requirements:\n\nclient (user) requirements\nsystem (developer) requirements: requirements from the point of view of the developer with more technical detail.\n\nUsually two different documents are created.\nTORE again:\n\ntask level:\n\ntasks\nroles, persona\n\ndomain level:\n\nsub-tasks\ndomain data\n\ninteraction level:\n\nsystem functions\ninteraction\nui-structure\n\nsystem-level: GUI\n\nscreen-structure (virtual window)\n\n\nabove levels can be categorized as follows:\n\n1, 2: client requirements\n3, 4: system requirements\n\nTwo different specification documents:\n\nlastenheft (client specification document)\npflichtenheft (developer specification document)"
  },
  {
    "objectID": "04/04.html",
    "href": "04/04.html",
    "title": "4  Design",
    "section": "",
    "text": "Design can be understood as communication with and within the developers.\nGoal: The software system can be further developed efficiently, and is easy to understand for new developers.\nBelongs to the development and specifically detailed design category of software development.\nDeals with the following topics:\n\nIntroduction to Modelling\nClass diagrams\nInteraction diagrams (sequence diagrams)\nState Diagrams\n\nUML State diagrams\nDialog models\n\nClass design with OOAD\n\nOOAD introduction\nOOAD: Analysis Class diagram\nOOAD: Design Class Diagram\n\nDesign Patterns\n\nIntroduction\nCreational patterns\nStructural patterns\nBehavioral patterns\n\nRationales (Communication of decisions)\nSummary of modelling techniques\n\n\n4.0.1 Introduction to Modelling\nA given team (approx 7 people) developes an understanding of the structure of the Software System, albeit without using code, since code is too detailed and is not conducive to understanding the overall structure of the software.\nInstead an appropriate abstraction level is necessary \\(\\Rightarrow\\) modelling languages.\nModel: Abstraction of a system, expressed in a formal language / notation where irrelevant details are omitted.\nCharacteristics of models:\n\nmapping\nincompleteness\npragmatic (a model is created with a certain purpose / goal)\n\nCharacteristics of a formal notation:\n\nsyntax\nsemantics\npragmatics\n\nanalysis techniques: type checking, consistency checks\nsimulation techniques\ntransformation techniques (refactoring, (algebraic) simplification)\ngeneration techniques\n\n\nA notation is a ‘theory’ that enables to reason about and manipulate representations of objects from the domain.\n\n4.0.1.1 UML\ndefines:\n\nStructure diagrams \\(\\rightarrow\\) statics of the system\nBehavior diagrams \\(\\rightarrow\\) dynamics of the system\n\ninteractions\nflows\nstate transitions\n\n\n\n4.0.1.1.1 Structure Diagrams\n\nDesign:\n\nClass Diagram (analysis and design)\nObject diagram (special cases)\npackage diagram (bundles of classes)\n\nArchitecture:\n\ncompositional structure diagram\nlogical component diagram (internal and external view)\ndistribution diagram (over the physical components)\n\n\n\n\n4.0.1.1.2 Behavior Diagrams\n\nFlows:\n\nUse case diagram (overview of the use case)\nactivity diagram (sequences of activities)\nstate diagram (sequences of states)\n\ninteraction:\n\nsequence diagram (sequence of messages)\ncommunication diagram (focus on a component)\ntime diagram (communication between automata)\ninteraction overview diagram (interaction of multiple interactions)\n\n\nIn the lecture especially:\n\nclass diagrams\nobject diagrams\ninteraction diagrams\nstate diagrams\n\n\n\n\n\n4.0.2 Class Diagrams\nimportant components of class diagrams:\n\nclasses (objects)\nassociations between classes:\n\naggregation\nkomposition\n\nattributes\noperations\ngeneralization / specialization relationship (inheritance)\ninterfaces: a view on a class (a contract)\n\n\n\n4.0.3 Interaction Diagrams (Sequence Diagrams)\n\n\n4.0.4 State Diagrams\n\n\n4.0.5 Class Design with OOAD\n\n\n4.0.6 Design Patterns\n\n\n4.0.7 Rationales (Communication of Decisions)\nDocuments contain only the last decision. Communication of all sorts of decisions and history of discarded decisions via Rationales.\nHow are rationales described:\n\nquestions: concrete problems that don’t have an obvious solution\noptions: describe alternative solutions to a problem\ncriteria: quality requirements\narguments: condensate and summarize discussions\ndecisions:\n\nrelates to one or more open questions\nsummarizes the chosen options and arguments that support it"
  },
  {
    "objectID": "05/05.html",
    "href": "05/05.html",
    "title": "5  Quality Assurance",
    "section": "",
    "text": "Quality: Software satisfies the requirements\ntopics:\n\nIntroduction\nOrganizational quality assurance\nTesting:\n\nIntro\nTest-case specification\nBlack-box component testing\nWhite-box component testing\nSystem testing\nIntegration testing / overall-component testing\n\nStatic testing\n\nStatic Analysis\nMetrics\nInspection\n\nAnalytical Quality assurance at large"
  },
  {
    "objectID": "06/06.html",
    "href": "06/06.html",
    "title": "6  Evolution",
    "section": "",
    "text": "All activities that facilitate re-use and further development. (All activities that take place after the initial development phase)\ntopics:\n\nIntro\nArchitecture\nRe-use\nFurther development and change management\nDevOps & IT-Governence\nRe-engineering"
  },
  {
    "objectID": "07/07.html",
    "href": "07/07.html",
    "title": "7  SWE Process & Project Management",
    "section": "",
    "text": "Making sure that the Software system is developed withing the time money constraints.\ntopics:\n\nProject management\nSWE-process models & methods"
  }
]
[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Software Engineering Lecture Notes WS 24/25",
    "section": "",
    "text": "Preface\nLecture notes for the course “Software Engineering” at Heidelberg University WS24/25."
  },
  {
    "objectID": "index.html#chapters",
    "href": "index.html#chapters",
    "title": "Software Engineering Lecture Notes WS 24/25",
    "section": "Chapters",
    "text": "Chapters\n\nIntroduction\nCommunication in a Project link\nRequirements Engineering (Communication with the Users) link\nDesign (Communication with Developers) link\nQuality Management link\nEvolution link\nSWE-Process (Summary and Project Management) link"
  },
  {
    "objectID": "01/01.html",
    "href": "01/01.html",
    "title": "1  Introduction to SE",
    "section": "",
    "text": "Core goals of software engineering:\n\nquality: software fulfills the requirements \\(\\Leftarrow\\) this\nusers: software is useful for the users\ndevelopers: it is easy to develop, maintain and modify the software\ncost / time: software can be implemented within the given cost & time constraints \\(\\Rightarrow\\) project management\n\nMain task categories of software engineering:\n\nDevelopment:\n\nDetermining the software context\nrequirements engineering\narchitecture\ndetailed design\nimplementation\nconfiguration management\n\nQuality management\n\nproduct: testing, inspection, metrics\nprocess: measurements, improvements\n\nEvolution:\n\nmaintenance\nfurther development / modification\nre-engineering / change management\n\nProject management:\n\nteam\ncosts\ntime / deadlines\nrisks\ncontractor / client"
  },
  {
    "objectID": "02/02.html",
    "href": "02/02.html",
    "title": "2  Communication in a Project",
    "section": "",
    "text": "Following topics relate to and determine communication within a project:\n\nNumber of participants and their roles in the project\nType of the contractual relationship\nTeam Organization: The way developers communicate within the project\nCollaborative Coding\n\n\nProjects and Participants\nterms relating to project and process:\n\nprocess:\nproject\nprocess model:\n\ncharacteristics of a project:\n\nlimited time\ncreator\npurpose\nclient\nresults\nmeans and tools\norganization and planning\n\nparticipants:\n\nclient\nuser\nmanufacturer\n\n\n\nContractual Relationship\nproject types:\n\nEP (Entwicklungsprojekt) -&gt; development project\nAP (Auftragsprojekt) -&gt; Commissioned Project\nEDP (EDV-Projekt, EDV = Elektronische Datenverarbeitung) -&gt; IT Project\nSP (Systemprojekt) -&gt; System Project\n\n\n\nTeam Organization\ntypes of team organization:\n\nsingle person\n2-person team\nanarchic team\ndemocratic team\nhierarchical team\nchief-programmer team\nagile team\n\ntypes of secondary organization:\n\nfunctional\nproject-based\nmatrix\n\n\n\nCollaborative Coding\n\nPair programming\nDistributed development"
  },
  {
    "objectID": "03/03.html",
    "href": "03/03.html",
    "title": "3  Requirements Engineering",
    "section": "",
    "text": "requirements engineering can be understood as corresponding to the communication with the users / clients. Deals with the following topics\n\nIntroduction to communication with users/clients.\n\nClients and Requirements\nDescription and specification of requirements\nDefining Requirements Engineering\nOutcome of Requirements Engineering\nBenefit of specification\nComplexities of RE\n\nUsage modelling / description\n\nIntroductory Example\nIntroduction\nTasks, Roles, Persona\nDomain Data\nFunctions, UI-Structure\nGUI\n\nDocumentation Quality\n\nIntroduction and Templates\nCharacteristics and style guide\n\nUsability\nQuality assurance with the client\n\nacceptance test\nusability test\n\nQuality requirements\n\nMotivation\nQuality attributes\nQR-description\nQR-test\n\nUse-cases (not relevant to the exam)\n\nDescription of Uses Cases\nUse for system testing\n\nRE procedure\n\nIntroduction\nGathering requirements\nSpecificying requirements\n\n\n\nCommunication with Users / Clients\n\nrequirements engineering:\n\ncollection of the requirements from the client\nspecification / formalization of the requirements\ntesting / examination of the requirements\nmanagement of the requirements\n\nrequirements engineering result:\n\ndocument:\n\ndescription using system functions\n\nprototype\n\nAdvantages and Uses of Specification:\nDisadvantages of a missing specification\nDifficulties related to RE:\n\n\n\nUsage Modelling\n\nTask-oriented Requirements Engineering:\n\nTask level: tasks, roles, persona\nDomain level: subtasks (as-is & to-be), domain data\ninteraction level: system functions, ui-structure\nsystem level: gui, screen-structure (virtual window)\n\n\nRoles, Persona, Tasks\n\nRoles, Persona\nUDC (User-centered design)\nRoles and Persona\n\nUser role:\nUser profile:\n\nHow are personae described:\n\nname\nbiographic facts: age, gender, etc\nknowledge and attitude with respect to the tasks and technology:\nneeds: main use-cases in which the user wants to apply the software -&gt; Tasks\nfrustrations:\nideal features:\n\n\n\nTasks\nHow tasks are described:\n\nGoals\nDecisions\nCauses\nPriority\nExecution profile (frequency, continuity, complexity)\nPrecondition\nInfo-in (input)\nInfo-out (output)\nresources (means, participating roles)\n\nsub-tasks:\nPersona-task correspondence:\n\nneeds &lt;=&gt; sub-tasks =&gt; combination of system-functions\nfrustrations &lt;=&gt; problems in sub-tasks\nideal features &lt;=&gt; ideas, system functions\n\n\n\nDomain Data\nDomain data explain the terms used in the task descriptions.\nGoal: describe/model the entities of real world, including their relationships / associations to each other, in order to understand the tasks.\n\ndomain data describe entities that are relevant within the context of the sofwtare. They correspond to the terms used in the task description =&gt; independent from the software.\ndescribed with simple class diagrams =&gt; domain data diagram (no operations, no aggregation, no inheritence, only associations)\nsometimes glossary is sufficient.\n\nsometimes not sufficient, because there additional data necessary on the UI level =&gt; interaction data. (not relevant in our MMAP case)\n\n\nFunctions & UI-Structure (Interaction Level)\nGoal: implementation of the User/Machine boundary with respect to the task descriptions.\nconsists of 2 parts:\n\nSystem functions: which functions are provided by the system?\nUI-Structure:\n\nin which context can the user call which functions,\nwhich data is available/visible in those contexts?\nhow are functionalities divided among the sub-parts?\n\n\n\n\n\n\n\n\nWarning\n\n\n\nUI-Structure is not GUI-structure, i.e. the concrete layout is not yet determined.\n\n\n\nSystem Functions\nhow is a system function described:\n\nname: nomenclature verb-object, describe what will be achieved on the user data (e.g. unlinkMovie =&gt; movie will be unlinked)\ninput:\n\ncontext (i.e. workspace) in which the SF accessible\n\nconcrete input: data that is gathered during the interaction with the user. Such data is not yet determined when the SF is first called on the GUI, but first provided by the user during the interaction.\noutput: changes of the UI\ndescription:\nexceptions: cancel/discard by the user\nrules:\nquality requirements:\nprecondition:\npostcondition:\n\n\n\nUI-Structure\nConsists of\n\nworkspaces:\n\nbundle related system functions and data similar to a class (but only from an abstract user point of view. Actual structure in code can be completely different)\nonly system functions that can be triggered by the user are listed\n\nnavigation links between workspaces\n\nUI-structure abstracts from a concrete screen-layout. Logical represents a logical view of the interaction structure.\n\n\n\n\n\n\nImportant\n\n\n\nUI-structure is created concurrently with the System functions, because their close interrelation. (Workspaces contain System functions and data)\n\n\n\n\n\nDesign of System Functions and UI-Structure\n\nhow is the system function specification template filled in?\nhow are ui-structure decision made concurrently to SF specifications?\ninitial test considerations?\n\nThere’s still lots of wiggle room for specific design decisions.\nTODO:\n\n\nGUI\nGUI= concrete layout of the UI:\n\ndata representation\nfunction representation\nwindow structure\ndialogue description (how user controls the execution of functions)\n\nDesign principles:\n\nlaw of proximity\nlaw of closure\nlaw of good continuation\nlaw of similarity\n\nTypes of functions:\n\nsemantic functions: actual data manipulation in the system, e.g. save, open, calculate something etc\nhelp functions / auxillary functions: data manipulation on the screen, e.g. text size\nsearch\nnavigation\n\nHow functions are represented:\n\nbuttons\ncheckbox\nmenu-selection\nshortcut\nicon\nscroll-bar\ndrag-and-drop\n\nViews (Window / Screen): concrete version of Workspaces:\n\nhow is data represented\nhow are functions made available / represented\n\nDocumentation of a view: Virtual Window (Mock-up)\n\n\n\nDocumentation Quality\nfollowing topics relate to it:\n\ndocument templates\nfeatures and sytle-guide\n\nmany documents exist:\n\nSoftware context-design:\n\nproblem-description\ncontract\nacceptance test plan\n\nRequirements Engineering:\n\nClient-requirements\nUsage test plan\nSoftware specification\nSystem test plan\n\narchitectural specification:\n\narchitectural specification / definition\nsub-system specification\n\nDetailed design:\n\ncomponent specification\nintegration test plan\n\nImplementation:\n\nCode\nComponent test plan\n\n\nCommunication happens via / is facilitated by documents\n\n\nUsability\nThe degree to which a product can be used efficiently and adequately for specific tasks / goals, in a specific usage context:\n\neffectivity\nefficiency\nsatisfaction\n\n7 interaction (dialogue) principles :\n\nTask appropriateness: no unnecessary repetitive actions must be taken bythe user\nSelf-descriptiveness: user knows what the actions achieve, what’s the input, output and the systems response.\nControllability: user can decide the order of the operations, can terminate the operation and resume at any given moment without loss.\nExpectation-conformity: system is consistent, confirms to users real-life experience and other software conventions\nError tolerance: even at the hands of an incorrect input the intended result can be achieved with minimum correction effort.\nUser engagement: system must be appealing and inviting and provide users a positive experience.\nLearnability: users are supported and guided during the learning of the software\n\n\n\nQuality Assurance with the Clients\n\nverification: whether the software being built confirms to the specifications derived from the requirements and whether the requierements documents meet quality standards\nvalidation: whether the specifications actually correspond to clients requirements \\(\\Rightarrow\\):\n\nusability test\nacceptance test\n\n\n\nAcceptance Test\n\nTests whether the client accepts the system \\(\\Rightarrow\\) validation.\nUses system tests provided by the client\nincludes particularly also usability tests.\ntests are carried out in the production environment (live system where the software is fully deployed and used by the clients)\n\n\n\nUsability Test\nA representative group of users from the target demographic of the product take part in the test to determine to what extent the usability criteria is met.\nConsists of:\n\nusers\nobservers\n\nhow:\n\ndevelop a test plan:\n\ngoal\ndescription of the problem\ndescription of the users\ntest design\nlist of tasks\ntest environment\nevaluation criteria\n\nprepare the test:\n\nrecruiting a representative group\nrecruiting observers\ndistribution and review of the test plan with the participants\nprepare scenarios\nprepare surveys: backgroung, pretest, posttest\nprepare test env\n\nexecute the test:\nanalyse the results\n\n\n\n\nQuality requirements\n\nMotivation\n\nfunctional requirements \\(\\Rightarrow\\) what?\n\ntasks\nsystem functions\ngui\n\nnon-functional requirements (NFR) \\(\\Rightarrow\\) how good?\n\nQuality of the system\n\nQR = quality requirements: describe product considerations\nQA = quality attributes\n\n\n\nQuality Attributes\nQA describe various types of software quality.\nCategories:\n\nQuality in Use: Direct validation with the users\n\nBeneficialness: how well are users supported\n\nusability\naccessibility\nsuitability\n\nfreedom from risk: general impact\nacceptability (how good is the system from the point of view of the user)\n\nsupport experience\ntrustworthiness\ncompliance (regulations, laws)\n\n\nSoftware Product Quality: verification (internally), validation (externally), continuously during the whole development process\n\nfunctional stability\n\nfunctional completeness\nfunctional correctness\nfunctional appropriateness (helpful)\n\nperformance efficiency\n\ntime behavior\nresource utilization\ncapacity\n\ncompatibility\n\nco-existence with other software\ninteroperability\n\ninteraction capability (usability)\n\nrecognizability\nlearnability\noperability\nuser error protection\nuser engagement\ninclusivity\nuser assistance\n\nreliability\n\nfaultlessness\navailability\nfault tolerance\nrecoverability\n\nsecurity\n\nconfidentiality\nintegrity\nnon-repudiation\naccountability\nauthenticity\n\nmaintainability\n\nmodularity\nreusability\nanalysability\nmodifiability\ntestability\n\nflexibility\n\nadaptability\nscalability\ninstallability\nreplaceability\n\nsafety\n\noperational constraint\nrisk identification\nfail safe\nhazard warning\nsafe integration\n\n\n\n\n\nDescribing QR\n\nQR should be made as measurable and as concrete as possible.\nQR are defined in parallel with the FR with as much detail as possible, for all levels:\n\nTasks\nDomain data\nFunctions\nGUI\n\n\n\n\nTesting QR\n\nDifferent QA categories require different testing methods.\nUsually only possible at the level of system testing, especially acceptance testing.\nUsually conducted by acting out scenarios\n\n\n\n\nUse Cases\nSo far we described the requirements via:\n\n(Sub)-Tasks\nDomain Data\nRoles / Persona\nSystem functions\nInteraction data\nUI Structure\n\nAt the system level this is further refined via:\n\nconcrete views\ninteraction models\n\nBut this is only an indirect description of users interaction with the system.\nUse Cases describe the specifics of users interactions with the system, specifically the particular execution sequence of system function to complete a certain (sub-)task. Thus, they are derived from Tasks\nuse cases vs TORE:\n\nuse cases cover only a subset of TORE. Particularly\n\nNo domain data model\nNo UI-Structure (which SF & Data are available in which view, how do you navigate between views)\n\nUC integrate SF within the execution flow, in TORE SF are contained in the subtask description (although without the execution flow)\n\n\nDescription of a UC\nExample: manage movie or performer ratings in MMAPP.\n\nName: Manage Rating\nActor: Person\nGoal: to rate movies or performers\nPrecondition: at least one movie exists. Depending on the current state wither A1 or A2 is the starting point:\n\nFlow of events:\n\nActor: A1) W0.1 Movie Master View … System: System shows the\n…\n\nRules:\nQuality requirements:\nData, System Functions:\nPostcondition:\n\n\n\n\nUse of System Tests\nScenario vs UC:\n\nScenario: a specific interaction flow\nUC: an abstract description of a set of scenarios\n\nA choice of a typical set of scenarios can be used as a template when creating a UC. On the other hand a UC can be validated by a subsequent creation of a set of test scenarios.\nWhat is a typical flow?\n\nnormal flow\ncoverage of branches / exceptions\ndealing with large input (stress test)\ndealing with complex execution flows (many functions are called)\n\n\n\n\nRE Procedure - Method of RE\nSo far we only concerned ourselves with describing the requirements. Here we explain how to gather and manage them.\n\nIntroduction\nStakeholder (client) requirements: the requirements stipulated by the client to achieve a certain goal or solve a certain problem.\n\nrequirements are gathered\nrequirements are formulated / formalized in the specification\nspecifications are validated and verified\nspecifications are translated into a design\nthe design is implemented\nthe implementation is tested\nthe implementation is deployed to the clients\n\n\n\nGathering Requirements\nwhat information should be gathered:\n\nprevious method to solve the problem\nproblems related to the previous method\ngoals for the new system / method to solve the problem\nsuccess criteria\nrough system architecture (how many components, distribution)\nrealistic solutions\nconsequences and risks\n\nhow it is gathered:\n\nobservation\nuser surveying\nethnographic studies\nuse cases\nworkshops\nobject oriented analysis\nentity relationship diagrams\nconceptual modelling\ndata flow diagram\nformal specification\nprototypes\nobservations of other products\nliterature research\nstudying standard software\n\nrequirements can also be gathered via user feedback\n\n\nSpecifying Requirements\ncontents and types of requirement specification:\n\nfunctional requirements: how should the software support the users?\nnon-functional requirements:\n\nquality requirements: how well should the software support the users?\nedge conditions\n\nrationales: reasoning behind the decisions?\n\nrequirement specification is textual as well as schematic (UML, ER etc)\nThere are two types of requirements:\n\nclient (user) requirements\nsystem (developer) requirements: requirements from the point of view of the developer with more technical detail.\n\nUsually two different documents are created.\nTORE again:\n\ntask level:\n\ntasks\nroles, persona\n\ndomain level:\n\nsub-tasks\ndomain data\n\ninteraction level:\n\nsystem functions\ninteraction\nui-structure\n\nsystem-level: GUI\n\nscreen-structure (virtual window)\n\n\nabove levels can be categorized as follows:\n\n1, 2: client requirements\n3, 4: system requirements\n\nTwo different specification documents:\n\nlastenheft (client specification document)\npflichtenheft (developer specification document)"
  },
  {
    "objectID": "04/04.html",
    "href": "04/04.html",
    "title": "4  Design",
    "section": "",
    "text": "Design can be understood as communication with and within the developers.\nGoal: The software system can be further developed efficiently, and is easy to understand for new developers.\nBelongs to the development and specifically detailed design category of software development.\nDeals with the following topics:\n\nIntroduction to Modelling\nClass diagrams\nInteraction diagrams\nState Diagrams\n\nUML State diagrams\nDialog models\n\nClass design with OOAD\n\nOOAD introduction\nOOAD: Analysis Class diagram\nOOAD: Design Class Diagram\n\nDesign Patterns\n\nIntroduction\nCreational patterns\nStructural patterns\nBehavioral patterns\n\nRationales (Communication of decisions)\nSummary of modelling techniques\n\n\nIntroduction to Modelling\nA given team (approx 7 people) developes an understanding of the structure of the Software System, albeit without using code, since code is too detailed and is not conducive to understanding the overall structure of the software.\nInstead an appropriate abstraction level is necessary \\(\\Rightarrow\\) modelling languages.\nModel: Abstraction of a system, expressed in a formal language / notation where irrelevant details are omitted.\nCharacteristics of models:\n\nmapping\nincompleteness\npragmatic (a model is created with a certain purpose / goal)\n\nCharacteristics of a formal notation:\n\nsyntax\nsemantics\npragmatics\n\nanalysis techniques: type checking, consistency checks\nsimulation techniques\ntransformation techniques (refactoring, (algebraic) simplification)\ngeneration techniques\n\n\nA notation is a ‘theory’ that enables to reason about and manipulate representations of objects from the domain.\n\n\n4 + 1 Architectural View Model\n4 different viewpoints representing different stakeholders:\n\nLogical View \\(\\rightarrow\\) End-users: functionality that the system provides to the end-users / clients.\nUML diagrams:\n\nclass diagrams\nstate diagrams\n\nProcess View: dynamic aspects of the system, description of the system processes, how they communicate, run-time behavior of the system: concurrency, distribution, performance, scalability, etc.\nUML diagrams:\n\nsequence diagram\ncommunication diagram\nactivity diagram\n\nDevelopment (Implementation) View \\(\\rightarrow\\) Programmers: system from programmers’ perspective, concerned with software management.\nUML diagrams:\n\npackage diagram\ncomponent diagram\n\nPhysical View \\(\\rightarrow\\) System-engineer: topology of the software components on the physical layer as well as the physical connection between these components.\nUML diagrams:\n\ndeployment diagram\n\n\n\n(+1): Scenarios / Use Case View:\n\nArchitecture is described using a small set of use cases or scenarios\nScenarios are Sequences of interactions between objects and between processes.\nused to identify architectural elements and to illustrate and validate the architectural design.\nused as a starting point for tests of an architecture prototype\n\n\n\n\nUML\nUML diagram categories:\n\nStructure diagrams \\(\\rightarrow\\) statics of the system:\n\nclass\nobject\ncomponent\ndeployment\npackage\ncomposite structure\n\nBehavior diagrams \\(\\rightarrow\\) dynamics of the system\n\ninteraction:\n\nsequence\ncommunication\ninteraction overview\ntiming\n\nUse Case\nDialgue Model / Activity\nState\n\n\nIn the lecture especially:\n\nclass diagrams\nobject diagrams\ninteraction diagrams\nstate diagrams\nDialogue Model / Activity Diagrams\n\n\nStructure Diagrams\n\nDesign:\n\nClass Diagram (analysis and design) (logical view)\nObject diagram (special cases) (logical view)\npackage diagram (bundles of classes) (development view)\n\nArchitecture:\n\ncompositional structure diagram\nlogical component diagram (internal and external view)\ndistribution diagram (over the physical components)\n\n\n\nClass Diagrams\nimportant components of class diagrams:\n\nclasses (objects)\nassociations between classes:\n\naggregation\nkomposition\n\nattributes\noperations\ngeneralization / specialization relationship (inheritance)\ninterfaces: a view on a class (a contract)\n\n\n\n\nBehavior Diagrams\n\nFlows:\n\nUse case diagram (overview of the use case)\nDialogue model / activity diagram (sequences of activities)\nstate diagram (sequences of states)\n\ninteraction:\n\nsequence diagram (sequence of messages)\ncommunication diagram (focus on a component)\ntime diagram (communication between automata)\ninteraction overview diagram (interaction of multiple interactions)\n\n\n\nState Diagrams\nUML extension of traditional state diagram aims to overcome some of the limitations FSMs. Thus UML state machines is an extension to the traditional mathematical FSMs.\nspecific to UML:\n\nhierarchically nested states\northogonal regions\nextended notion of actions\ncharacteristics of both Mealy and Moore machines:\n\nMealy: actions that depend both on the state and the triggering event\nMoore: entry and exit action (only associated with states, not transitions)\n\n\nMany software systems are event-driven (also called reactive):\n\nmouse click\nbutton press\ntime tick\narrival of a data packet\n…\n\nSoftware systems react to events by taking actions and changing to another state \\(\\Rightarrow\\) state transition. Advantages of using an FSM model to underlie the code:\n\nreduce the number of execution paths through the code\nsimplify the conditions tested at each branching point\nsimplify switching between different modes of execution.\n\n\nBasic UML State Diagrams\n\nstate: rounded rectangles labeled with state names\ntransitions: arrows labeled with the triggering events optionally followed by list of actions\nevent / trigger: the thing that causes the state transition\naction: the optional thing carried out by the system as a response to the event\ninitial transition: originates from the solid circle (the default initial state when the system first begins - entry point) every diagram should have it. initial transitions can have associated actions\n\n\n\n\nbasic uml state diagram\n\n\n\n\nElements of UML state machines:\n\nevent / trigger: something that happens that effects the system.\n\ncan have associated parameters\nan event instance can have a long life-cycle\n\nstate: Governs the reaction of the state machine to events.\n\na state can abstract away all possible (but irrelevant) event sequences and only capture the relevant ones.\nin the context of software systems a state is a single variable that can have only a limited number of values, usually an provided by an enum type \\(\\Rightarrow\\) the value of the state variables fully defines thet current state of the system at any given time\n\nextended state: However interpreting the whole state of machines can become impractical very quickly (state explosion) \\(\\Rightarrow\\) in UML state is spilt up into:\n\nenumerable state variable. Corresponds to the qualitative aspect of the whole state\nall other variables which (extended state). Corresponds to the quantitative aspect of the whole state. Quantitative aspects do not lead to a state change. (See below for more explanation)\n\nguard condition: in extended UML a transition can have a guard \\(\\Rightarrow\\) transitions only fires if the guard is evaluated to true, related to extended states, simplifies number of states.\nactions and transitions: response of the system to an even/trigger.\n\naction:\n\nchanging a variable\nperforming I/O\ninvoking a function\ngenerating another event instance\nchanging to another state\n…\n\nstate transition: switching from one state to another state\n\nrun-to-completion execution model (RTC): processing of each event must carried out to completion before the next event can be carried out.\n\nincoming event can not interrupt this and are instead stored in an event queue\nThis avoids internal concurrency issues within a single state machine.\nDuring even processing the system is unresponsive / unobservable.\nAdvantage: simplicity\nDisadvantage: responsiveness of a state machines is determined by its longest RTC step.\n\nhierarchically nested states: repeating transitions common to a group of states can be factored out as a super (outer) state.\n\nthe complexity of the state machine doesn’t explode (see calculator example below for more details)\nsemantics:\n\nif a system is in a substate surrounded by a superstate, it is automatically also in that superstate, i.e. the superstate is inherited.\nthe state machine will try to handle any event first in the context of the substate, but if it is not defined, it will delegated to the superstate.\n\n\n\northogonal regions: compatible and independent regions of states that happen simultaneously. (AND-decomposition). \\(\\Rightarrow\\) reduction of combinatorial explosion of sates.\nentry and exit actions: always automatically executed upon entry to state or an exit from a state. \\(\\Rightarrow\\) guaranteed initialization and cleanup.\ninternal transitions: self transitions can be instead represented as internal transition (without executing the entry and exit actions)\ntransition execution sequence:\nlocal versus external transitions:\nevent deferral:\n\n\n\nExtended State Example\nAssume we want to introduce a limit to the number of times keys can be pressed on keyboard, from the beginning of its execution. In traditional way we would have to introduce 1000 states that would approach the final state incrementally (state explosion). Instead this quantitative information can be captured in an additional variable that does not effect the qualitative state of the system, and is managed via guard conditions:\nbasically, extended state == variable not represented as state, that interacts with guard conditions.\n\n\n\nextended uml state machine exmaple\n\n\n\n\nHierarchical States Calculator Example\nModelling a simple pocket calculator with traditional FSM introduces many repetitive transitions:\n\nfor every state the event ‘C’ changes the state to operand1\nfor every state the event ‘OFF’ changes to the exit state.\n\nUsing the superstate on, this common behavior factored out and the total number of transitions is greatly reduced. Now when the system is, say, in the state opEntered and event ‘C’ takes place, it can’t be handled by the inner state since it is not defined. Then, by the semantics of the UML state machines, this event is relegated to the outer state, where it is defined to transition to itself. From there it enters the inner states entry point, which changes the state to operand1.\nAnalogue for ‘OFF’.\n\n\n\nhierarchical states calculator example\n\n\n\n\n\nDialog Models / Activity\nDialog Model: state diagrams applied to UI.\n\nstate \\(\\Rightarrow\\) view\ntransition \\(\\Rightarrow\\) execution of a function\n\nHistory Sates:\n\nH*: the previous innermost view / state\nH: the previous superstate.\n\n\n\nInteraction Diagrams\ninteraction diagrams describe communication between various actors.\nVarious uml interaction diagrams:\n\nsequence diagrams\ncommunication diagrams\ntime diagram\ninteraction overview diagram\n\n\nSequence Diagram\nIn programs many objects collaborate with each other to carry out functionality. An objects collaborates with another by sending messages to it.\n\nsending message to an object \\(\\Rightarrow\\) calling it’s method: myCDplayer.play(\"Song 1\");\nmyCDplayer itself can collaborate with it’s own instance (member) variables, and the input parameter object \"Song 1\"\nCollaboration between objects java implies having references to the same object from several locations in the program.\n\nAlso called event diagrams or event scenarios.\nShow process interactions arranged in time sequence. Depicts the processes and objects involved and the sequence of messages exchanged to carry out functionality.\n\n\n\nseq diag\n\n\nrectangles represent the duration during which the object is active.\n\n\n\n\n\nClass Design with OOAD\nSteps of the software process:\n\nanalysis and specification: gathering and representing requirements\ndesign: structure and architecture of the software is defined\ncoding: implementation of the end product in detail.\n\nDesign has the following goals:\n\npartitioning the system into manageable units\nlaying out a structure: relationship between the units / parts that make up the whole system\nhierarchical partitioning: abstraction that helps understand and maintain a large software system\n\nresults from requirements:\n\nDomain / Interaction data diagram: specification of the data in detail\nSFs or UCs: specification of functionality / how functionality is carried out\nWorkspaces (UI-Structure): How and where is the data & SF represented and provided for the user, as well as the navigation between the workspaces.\nView (Virtual Window): the mockup of the GUI\n\nConsideration when making design decisions:\n\nData management classes: implementation of domain / interaction data diagram\n\nwhich data which classes?\ncan some entities be directly taken as classes?\nwhat operations are necessary?\nhow is data storage implemented?\n\nClasses for internal processing: Implementation of SFs\n\nhow are SFs implemented / distributed among operations of which classes? (note that SFs do not generally correspond to individual operations, but are combinations of multiple ops)\n\nUI classes: Implement the views (virtual windows) and the navigation from the UI-structure.\n\n\nDesign Principles: Cohesion and Coupling\n\nCohesion\nA measure of or degree to how much the elements of a component belong together.\nGoal: high cohesion, i.e. elements within a module or component belong together strongly, are highly interdependent \\(\\Rightarrow\\) good for maintenance.\nWe can’t easily partition a highly cohesive module into subparts, where the subparts are independent of each other.\nHow to achieve high cohesion:\n\nprinciples of object orientation (data encapsulation)\nusing appropriate design patterns for coupling and decoupling\n\n\n\nCoupling\nA measure of the degree of how strongly different components depend on one another.\nGoal: low coupling, i.e. low interdependence between different components\nLow coupling is good for performance (communication is simpler)\nhow to reduce coupling:\n\ninterface coupling: information exchange takes place only via interfaces.\ncomponents should call other components as little as possible\ndata coupling should be avoided: no shared data among different components\nstructure coupling should avoided: no shared structure among different components\n\nSimple and complex operations:\n\nSimple operation: only direct access of attributes (class access it’s own attributues)\nComplex operation: direct as well as indirect access of attributes (indirect access: class A access attributes of class B)\n\nincrease coupling\nhinder cohesion\n\n\nComplex operations should therefore be split up in smaller operations, or encapsulated in own class whose data they access.\n\n\n\nOOAD\nObject-oriented analysis & design \\(\\Rightarrow\\) systematic development of the design model\nthe process of: requirements \\(\\Rightarrow\\) class diagram:\n\nwhat decision should be made and how?\nwhat classes are needed, with what operations and attributes should the classes be equipped?\n\nOOAD 2 step method:\n\nAnalysis class model: defines class structure based on the requirements\nDesign class model: concrete implementation of the analysis class model using frameworks, libraries and concrete classes, taking design goals, especially NFRs.\n\n\nAnalysis Class Model / Diagram\n4 Steps:\n\nDetermine classes, attributes, and association from the requirements, with appropriate names.\nDetermine the operations of the classes: distribute basic operations and SFs as methods (operations) in classes, taking high cohesion and low coupling into account.\nDetermine complex associations and inheritance relationships\nConsolidate the class diagram: possibly dissolve interaction / ui classes, consolidate associations.\n\n3 types of classes:\n\nentity class: describes objects with permanent existence\n\ne.g.: film, actor.\n\ncontrol class: describes processes. SFs are initially modelled as such. Serve as placeholder for complex operations, ultimately are dissolved and distributed as methods among various appropriate classes\nboundary / interaction / dialogue class: bundles data and operations that are provided on the UI.\n\n\nStep 1\nGoal: Determine / derive classes from the requirements\nRules:\n\nEntity classes:\n\nEntities from the data diagram become entity classes, e.g. film and actor.\nassociations from the data diagram become the associates between the classes\n\nControl classes:\n\nSF are initially modelled as such\ncontrol classes are linked to the entity classes, whose attributes they access\ncontrol classes are linked to other control classes, which they cooperate with.\n\nBoundary classes:\n\nWorkspaces \\(\\Rightarrow\\) boundary classes\nare linked to the entity classes, that are displayed in the workspace\nare linked to the control classes of the SFs that are provided on the UI interface.\nnavigation between workspaces \\(\\Rightarrow\\) links / associations between boundary classes.\n\n\n\n\nStep 2\nGoal: Determine the operations of the classes, dissolve control classes by distributing them among the various classes as methods. (occasionally a control class can be retained as a concrete class)\nRules:\n\nDissolve control classes by distributing them among entity and dialogue classes:\n\ncanonical solution: if control class operates only on the attributes of a single class, it becomes a method in that class.\nsimple solution: if multiple classes are involved, but the input and output are associated to one class respectively, then the the control class can be … ?\ncomplex solution: if multiple classes are involved, and the output and input relate to multiple classes, then … ? \\(\\Rightarrow\\) sometimes objectification of the control class\n\nOperations can be split up or united, depending on the situation.\n\nan operation can cover multiple SFs (only for the canonical solution)\nSFs can be implemented by multiple operations\n\n\n\n\nStep 3\nGoal: Use inheritance and model complex associations\n\n\nStep 4\nConsolidate the model and possibly dissolve the interaction classes\nRules:\n\nplace interaction (ui) classes in a separate layer (e.g GUI layer)\nalternatively assign dialogue classes to some other classes: in this case the class is responsible both for data and representation on the GUI\nrevising the associations: cover all possible communication links\n\neach class that has a complex operation must be associated to the classes that they call\nconsolidate the associations\nprovide multiplicities (cardinalities)\n\nno redundant links: associations that are not used in any SF should be removed.\n\n\n\n\nDesign Class Diagram / Model\nGoal: preparation for coding by taking design goals into account.\nAnalysis class diagram gets refined with infrastructure classes (e.g. library) and completed, often using design patterns.\nSteps:\n\ncomplete the list of attributes and operations\ndetermine the data types and access specifiers (private, protected, public, etc)\nspecify operations (pre- and postconditions)\ndefine exceptions\nspecify concrete data structures that realize associations\neliminate multiple inheritance\nConsolidation via sequence diagrams\n\n\nStep 3 - Specifying Operations\n\nSpecification of an operation\n\nspecifying the behavior of an operation by providing a contract, without providing the algorithm\n\nDesign by Contract\n\nspecifying an operation by providing pre-, post-condition and an invariant\n\n\n\nUsually only textual\nSometimes directly supported by programming languages, e.g\n\nJavadoc comments in Java\nAssert in Java\n\n\n\n\nStep 4 - Specifying Exceptions\nError situations in code are usually represented as special output values, however this does not guarantee that the caller will deal with the error.\nInstead some programming languages have explicit error handling mechanisms called exceptions\nin java:\ntry {\n  // code that throws and exception of type E\n} catch (E e) {\n  // what to do with the caught exception\n}\nException types:\n\nExceptions in the domain: input doesn’t satisfy precondition, business logic is violated\nTechnical failure: Connection to server failed, called object doesn’t exist\n\nWays to deal with exceptions:\n\ndirectly: using a specific operation\nhanding over to the outside: via try-catch block\nnot treating: letting the run-time system eventually catch the exceptions\n\n\n\nStep 5 - Determining Concrete Data Structures\n\nConcretizing associations with a qualifier data structure:\n\n\n\n\nconcretizing with qualifier\n\n\n\nconcretizing associations by providing a fixed order: if there is a fixed order the objects associated to some other objects exist, this order can be fixed via a list or iterators.\n\n\n\nStep 6 - Eliminating Multiple Inheritance\nIt is common to have multiple inheritance relationships in analysis models. This should be eliminated in design models using interfaces.\n\n\nStep 7 - Consolidation via Sequence Diagrams\nImplementations of complex operations (SFs) should be checked using sequence diagrams for:\n\nhigh coupling: are too many objects and too many method calls used for the implementation? Yes \\(\\Rightarrow\\) reduce it by repartitoning the SF into operations\nlow cohesion: is there an operation of a class that works with disjoint sets of attributes? Yes \\(\\Rightarrow\\) can the class be partitioned into multiple classes and will it help with the complexity?\n\n\n\n\n\n\nDesign Patterns\nTransferring experience of good class structure design. Design patterns describes the roles of classes, their dependencies and associations.\nTypes of design patterns:\n\ncreational patterns (Erzeugungsmuster)\nstructural patterns\nbehavioral patterns (Verhaltensmuster)\n\nHow a pattern is described:\n\nname:\nproblem: motivation, field of application, problem class\nsolution:\n\nstructure (class diagram)\nelements (classes, their associations, and their operations)\ninteractions of objects (sequence diagram)\n\ndiscussion:\n\nadvantages and disadvantages: when and why should be applied\ndependencies, limitations\nspecial cases\nknown applications (how common is it, how mature is it)\n\n\nadvantages:\n\nproven solutions to recurring problems\nbetter readability & maintainability of software design and source code\neasier communication via a common vocabulary / language of patterns\n\namong architects and developers\namong developers\n\n\ndisadvantages:\n\nusing a pattern in a false context: overhead due to unnecessary classes, bad readability, maintainability etc\n\n\nCreational Patterns\nDeal with creation of objects:\n\ntry to hide, unify or simplify it\ndescribe what is created, how and when\n\nExamples:\n\nsingleton\nabstract superclass\nfactory method\nprototype\nbuilder\n\n\nSingleton\n\nproblem: there can exist only a single instance object of a given type.\nsolution:\npublic final class S {\n  private static S instance;\n  private S(); // private constructor\n  public static S getInstance () {\n    if (instance == null) instance = new S();\n    return instance;\n  }\n}\n\n// usage of singleton \n// S s = new S() can't be called because constructor is private, instead\nS s = S.getInstance(); // s refers to the single central initialized static instance of S\n\n\n\nFactory Method\n\nproblem: When creating an object, we don’t want to have to specify their exact classes, i.e we should be able to choose between variouis variants of a product.\nsolution:\n\nRather than creating an object by calling a constructor, the creation of the object is delegated to a factory method\nThe code that creates the object is outsourced to an own class called Factory or Creator. Optionally the Creator / Factory class can be abstract or an interface and the object creation can be implemented in subclasses inheriting from it \\(\\Rightarrow\\) subclass decides which object type is to be created.\n\n\n\n\n\nfactory design pattern\n\n\n\n\nBuilder\n\nproblem: Objects of the a class can be very different if they are complex, requiring a different constructions. How can the creation of a complex object be simplified, specifically, how can the creation of a process be abstracted from its representation, so that the details of the way the object is created can be later easily changed, without having to modify the class?\nsolution: Encapsulate the building of a complex object in a separate Builder class, to which the creaetion of the object is delegated to, instead of creating it directly\n\n\n\n\nbuilder pattern\n\n\n\nDirector: assembles the object from the sub-parts whose construction is delegated to Builder objects.\nBuilder: the abstract interface for creating objects (products)\nConcreteBuilder: provides the implementation for the builder\n\n\n\nAbstract Superclass\n\nproblem: different classes contain identical groups of attributes and methods\nsolution: refactor the classes, such that the common groups of attributes and methods are separated in an abstract super class, from which the old classes inherit.\n\n\n\n\nStructural Patterns\nDeal with combinations and relationships of classes \\(\\Rightarrow\\) allow building larger structures\nexamples:\n\nComposite\nadapter\nproxy\nbridge\ndirector\nfacade\nflyweight\n\n\nComposite Pattern\n\nproblem: modelling and implementing hierarchical (tree) structures\nsolution: a uniform abstract super class from which a leaf and a node class inherits\n\n\n\n\ncomposite design pattern\n\n\n\n\nAdapter Pattern\nAlso called wrapper\n\nproblem: A Class A (client) requires a class with a certain interface. There is another class B, that provides a different kind of interface. We would like to use class B in class A, even though the interface that B provides is not what A requires.\nsolution: Define a separate adapter class that converts the incompatible interface of class B (adaptee, i.e. the class to be adapted) into the interface that A expects. (this interface is called the target interface).\n\n\n\n\nadapter design pattern\n\n\n\n\nProxy\n\nproblem:\n\nAccess to an object should be controlled (because it is expensive or sensitive from a security standpoint)\nAdditional functionality should be provided when accessing an object\n\nsolution: A separate proxy object that can be used as a substitute for the other object (subject). Proxy implements necessary additional functionality.\n\n\n\n\nproxy design pattern\n\n\n\n\n\nBehavioral Patterns\nDeal with algorithms and assigning states to objects. Describe not only classes and objects but their interactions.\nexamples:\n\ntemplate method pattern\ncommand\nobserver\nvisitor\ninterpreter\nmemento\nstrategy\niterator\nmediator\nstate\nchain of responsibility\n\n\nTemplate Method Pattern\n\nproblem: a method consists both from fixed but also from changeable elements\nsolution:\n\ndefine a template method, that comprises the scaffolding of the method\nthe algorithm is concretely implemented in the inheriting subclasses\nfixed components making up the method are factored to the superclass\n\n\n\n\nChain of Responsibility\n\nproblem:\n\nThe sender of a request / message and the receiver of the message shouldn’t be coupled, or only loosely coupled.\nIt should be possible for more than one receiver to handle the request in flexible ways\n\nsolution: A chain of receiver objects that, depending on run-time conditions, either handle the request or forward it to the next receiver. This enables a flexible handling of the request. In other words the sender does not know which object will handle the request or how exactly.\n\n\n\nObserver\n\nproblem: There is a one to many relationship between an object called subject, and its dependencies, called observers. Observers must be notified whenever the state of the subject changes and react to it. In other words observers “observe” the subject and react to its state changes.\nsolution:\n\nSubject maintains a list of observers. Observers have methods to subscribe to or unsubscribe from the list.\nSubject has a method called notify(), that calls the update() method in each of the observers that are in the subscribers list. The update() method of each observer updates each one, making it to react to the state change of the subject.\n\n\n\n\n\nobserver pattern\n\n\n\n\nVisitor\n\n\nStrategy\n\n\n\n\nRationales (Communication of Decisions)\nDocuments contain only the last decision. Communication of all sorts of decisions and history of discarded decisions via Rationales.\nHow are rationales described:\n\nquestions: concrete problems that don’t have an obvious solution\noptions: describe alternative solutions to a problem\ncriteria: quality requirements\narguments: condensate and summarize discussions\ndecisions:\n\nrelates to one or more open questions\nsummarizes the chosen options and arguments that support it"
  },
  {
    "objectID": "05/05.html",
    "href": "05/05.html",
    "title": "5  Quality Assurance",
    "section": "",
    "text": "Quality: Software satisfies the requirements\ntopics:\n\nIntroduction\nOrganizational quality assurance\nTesting:\n\nIntro\nTest-case specification\nBlack-box component testing\nWhite-box component testing\nSystem testing\nIntegration testing / overall-component testing\n\nStatic testing\n\nStatic Analysis\nMetrics\nInspection\n\nAnalytical Quality assurance at large\n\n\nIntroduction\nCore goals of software engineering:\n\nquality: software fulfills the requirements \\(\\Leftarrow\\) this\nusers: software is useful for the users\ndevelopers: it is easy to develop, maintain and modify the software\ncost / time: software can be implemented within the given cost & time constraints \\(\\Rightarrow\\) project management\n\nMethods of quality control are based on the following questions:\n\nwhat are the requirements?\nwhat errors are there in the system?\nhow do the errors originate and manifest in the system?\nhow to prevent errors?\n\n\nTerms\nValidation vs Verification:\n\nVerification: the product fulfills requirements\nValidation: the requirements correspond to users wishes\n\nError and deficiency\n\nError: discrepancy between the product and the requirements\nDeficiency: a requirement or an expectation is fulfilled insufficiently\n\nFurther terms:\n\nindividual mistake by a person \\(\\Rightarrow\\) standards, norms, training\nerroneous state / deficiency in a program \\(\\Rightarrow\\) debugging\nerror that manifest in the system \\(\\Rightarrow\\) testing\n\nAbove 1 \\(\\Rightarrow\\) 2 \\(\\Rightarrow\\) 3.\nHow is quality control achieved:\n\nQuality management: general\nQuality assurance / QA: concrete processes to achieve quality\n\nConstructive QA \\(\\Rightarrow\\) design, implementation, programming\nAnalytical QA \\(\\Rightarrow\\) formal proof, inspection, static linting, dynamic testing\nOrganizational QA \\(\\Rightarrow\\) project management\n\n\n\n\n\nTesting\n\nIntroduction\nGoals is to find errors that manifest in the system (Fehlerwirkung) \\(\\Rightarrow\\) Systematic test:\n\nPre-/Postconditions are defined precisesly\nInputs are systematically specified\nResults are documented and analyzed w.r.t testing criteria\n\ncombinatorial state explosion \\(\\Rightarrow\\) Complete testing is never possible\nTerms:\n\nBase: all documents that the test case is derived from (requirements etc)\nTest case: consists of\n\ncollection of inputs\npreconditions and edge cases\nexpected results\nexpected exceptions\n\nPrecondition: the state of the object / environment, that must be specified, s.t. a test-case can be run\nPostcondition the state of the object / environment after the execution of the test case.\nTest run: execution of test or the suit of tests on a specific version of the test object\nReaction of the test object: The sequence of internal states, reactions and outputs of the tested object. They must agree with the requirements / expectation (ideally tested automatically)\nspecification: determining test objects and their test cases, choosing the testing methods\n\nderivation from the documentation and logical test cases\ncondition to end the test\n\n\nTest stages:\n\nComponent / Unit Test\nIntegration test: integrating components with each other\nSystem test: whole system\nacceptance test: after release, by the user / client\n\n(1)\\(\\Rightarrow\\) (2) \\(\\Rightarrow\\) (3) \\(\\Rightarrow\\) (4)\nRegression Test: after changes in the software test to see if changes craeted new errors\n\n\nTest-case Specification\nElements of a test case:\n\nexpected behavior based on a test oracle:\n\nrequirements specification\nuser manual\nexecutable prototype (formal specification)\nold version\n\ntwo abstraction levels when describing the test case\n\nlogical: range of input / output, possibly via equivalence classes\nconcrete: specific input / output values, possibly representatives of equivalence classes\n\n\nDescription of a test case:\n\nname\ntested requirement / relation to a requirement\ntype: component, integration, system, acceptance\nprecondition\npostcondition\ntest infrastructure\ndescription of test steps. For each step:\n\ninput\nexpected output\nexpected exception\n\n\n\n\nComponent\nComponent: a self-contained code unit \\(\\Rightarrow\\) class, function, module\ntypical erroneous behavior of a component:\n\nnon-termination\nincorrect or incomplete result\nunexpected / incorrect error message\ninconsistent memory\nsuperfluous resource load\nunexpected exception behavior, e.g. crash\n\nComponent test types:\n\nBlack-box: no knowledge of the internal implementation of the object, only the interface and specification.\nWhite-box: purposeful testing inner elements and the flow of execution, using the knowledge of its internal structure.\nIntuitive: based on knowledge / experience of typical errors \\(\\Rightarrow\\) supplementary to the two systematic test above.\n\n\n\nBlack-box Component Testing\nProperties of a black-box test:\n\nTest cases are derived from the input / output behavior of the operation (specification)\nThe goal when deriving the text cases is the coverage of:\n\ninput values\noutput values\nspecified exceptions\n\nespecially tests that all the requirements on the operation are satisfied.\n\nTest case description for a an operation / method test:\n\nname\ntested component (class)\ntype: component test\nprecondition: regarding relevant component data and restriction on the input\npostcondition: updated component data\ntest steps: detailed description of the steps,\n\ninput\nexpected output\nexpected exception\n\n\n\nEquivalence Class Tests\nEquivalence class:\n\nIdea: Partitioning of the range of input / output values into classes, such that values from the same equivalence class demonstrate conceptually same behavior and a single value from that class can be chosen as a representative.\nBoundary values: if the rang of values of an EQ are ordered, then\n\nvalues on both of the exact boundaries (min and max)\nas well as the neighbors of the boundaries: pred(min), succ(min), pred(max), succ(max)\n\n\ntypical equivalence classes:\n\ninput:\n\nValid input EQ (GEK): Valid input range, possibly subdivided w.r.t. the boundary values\nInvalid input EQ (UEK): invalid input range\n\noutput:\n\nValid output EQ (GAK): partitioning of valid input ranges s.t. various typical output values are covered (also possible subdivisions w.r.t boundary values)\nInvalid output EQ (UAK): Exceptions\n\n\nDeriving test cases based on EQ\n\nif there are multiple inputs:\n\ncombine all valid EQs of various inputs (cartesian product) ({GEK1, GAK1} x … x {GEKn, GAKn})\ncombine all valid EQs with all possible invalid EQs {GEK1, GAK1, … , GEKn, GAKn} x {UEK1, UAK1, …, UEKn, UAKn}\n\n\nSimplification:\n\nonly frequent combinations\nonly test cases with boundary values\nonly pair-wise combinations\n\nMinimal:\n\neach valid equivalence appears in one test case\n\n\n\n\nWhite-box Component Test\nwhite-box component test:\n\nTest cases are derived from the knowledge of the code base.\nThe goal is to test weather all of parts of the code are correct.\nRequirements specification is additionally necessary as a test oracle , i.e to determine what the results of the tests should be.\n\nMain goal is the achieve coverage of the code:\n\nStatement Coverage\nBranching Coverage\nPath Coverage\n\nCoverage can be seen on the control-flow graph\n\nControl-flow Graph\nControl-flow graph is an abstraction of the code, s.t.:\n\nconsecutive statements are united\nall branches are visible: multiple execution flows from a statement \\(\\Rightarrow\\) individual node.\njumps \\(\\Rightarrow\\) individual nodes\npossibly few nodes!\n\n\n\n\ncontrol-flow graph example\n\n\nRules:\n\nconsecutive statements until the end of a block, especially until the next if-branching or while-loop are combined to a single node. (the branching or loop condition can be included in the node as well)\nif a block consist of multiple nodes the brace closing the block gets its own individual node. (other than the brace closing the program)\nThe node of the negative case of an if-else branch contains the else line and the following statements.\nThe condition of a loop-statement get an individual node (due to the jump).\nIf earlier return statements exist in the program, the return statement becomes a node that can be reached in various ways.\n\n\n\nStatement, Branching, Path and Term Coverage\n\nStatement Coverage\nNodes in the control flow graph are (combinations) of statements. 100%-statement coverage \\(\\Rightarrow\\) all nodes of the graph are visited. In the previous example:\n\n(1-4) \\(\\Rightarrow\\) (5-7) \\(\\Rightarrow\\) (8) \\(\\Rightarrow\\) (9 - 10) \\(\\Rightarrow\\) (13,14) \\(\\Rightarrow\\) (15) \\(\\Rightarrow\\) (18) \\(\\Rightarrow\\) (19) \\(\\Rightarrow\\) (8) \\(\\Rightarrow\\) (9-10) \\(\\Rightarrow\\) (13-14) \\(\\Rightarrow\\) (16,17) \\(\\Rightarrow\\) (18) \\(\\Rightarrow\\) (19) \\(\\Rightarrow\\) (8) \\(\\Rightarrow\\) (20) \\(\\Rightarrow\\) (21)\n\nWhich input achieves this sequence? \\(\\Rightarrow\\) key == 15, a == [1, 15, 17, 19, 20]\n\n\n\n\n\n\nNote\n\n\n\n100% node coverage does not imply that all equivalence classes are covered\n\n\n\n\nBranch Coverage\nbranch coverage:\n\nedges \\(\\Rightarrow\\) branches.\nbranch coverage \\(\\Rightarrow\\) all edges are visited\n\nprevious example doesn’t cover the edge (1-4)\\(\\Rightarrow\\)(21). This corresponds to the case when the input array is empty: a == [], which in turn is a UAK.\n\n\n\nTerm Coverage\n\nFor complex branching and loop conditions every part making up the condition should be covered, i.e. every term making up the complete expression is “activated” at least once, for both when the whole condition is true, as well as false.\nGoal is to discover possible bugs due to individual terms.\n\nExample: if(X or Y). Here X and Y are terms and X or Y is the complex condition.\n\n\nPath Coverage\n\nPath: Sequences / combinations of edges\n100% path coverage not feasible & not easy to define.\n\n\n\n\nGrey-box Testing: White-box + Black-Box\n\nfirst define black-box test cases: simpler, since only requirements are sufficient.\ncheck which portions of code are not reached by the black-box tests. (e.g. with coverage plugins)\ncomplete the test suite by writing additional white-box tests such that 100% statement and brach coverage is achieved.\n\n\n\nClass / Object Test\nPreviously we discussed testing smaller units, like methods. We can also test larger components like classes (objects).\nIndividual methods of class \\(\\Rightarrow\\) gray-box.\nBut for testing interoperability of the methods of the whole class \\(\\Rightarrow\\) state based test based on the state diagram of the object. Testcases are then sequences of methods calls on the object that traverse various states of the object.\n\n\nSystem Test\nSystem test:\n\nTest weather client requirements are correctly implemented \\(\\Rightarrow\\) verification.\nTest environment should be as close to production environment as possible, but the production environment itself is not usually completely appropriate because lack or control and risk of damage.\nBoth individual SF’s as well as seqences of SFs (Use Cases) can be tested.\nquality features should be tested (performance, security etc)\n\n\nBlack-box test case specifications for system tests:\n\nname\ntested system function\ntype: systemtest\nprecondition system: precondition on the data\nprecondition GUI: what is shown on the GUI? \\(\\Leftarrow\\) new\ntest steps: actions that need to be taken on the GUI for data input and calling the SF.\nexpected exceptions: problems that can occur during the exeuction of the test \\(\\Rightarrow\\) Error message / error dialogue, or unavailability of SFs\npostcondition system: postcondition on the data\npostcondition GUI: What is the state of the GUI after successful execution?\n\n\n\n\nIntegration Test\n\ntest the interoperability of components\nassumes that components are correct (tested)\ntest against an technical specification (design)\ncomponents are integrated incrementally, step-by-step.\nrequires monitors: units that observe interfaces between components.\nrequires stubs / drivers that temporarily stand for not yet tested components\n\n\nHow are components interrelated ?\n\ncommunication: a component calls a method of another\nshared data: components access shared resrouces (variables, data, database), or use same data as a communication medium (asynchronously).\nshared system resources: cpu, memory, hard disk.\n\n\n\nPossible problems when components are integrated\n\nWrong receiver of a message\nWrong service / operation (operation is missing or incompletely implemented)\nWrong call time (preconditions of the receiver are not met)\nViolation of message / calls sequences\nMistakes in data passing:\n\npassed data is syntactically incorrect\npassed data is interpreted incorrectly\n\nIncorrect memory management (allocation / deallocation)\nMistakes in OS / Middleware (Database, ORB) calls\nConfiguration and version inconsistencies\nDivergent / conflicting interpretations of requirements by different teams (especially in distributed development)\nIncorrect usage of an interface.\nSynchronization in real-time systems.\n\n\n\nCoverage in Integration Tests\n\nIntegration test should test the interoperability between all components.\n\nwhich order, which components first?\ndifficult to achieve this systematically, because of various complex and circular interdependencies.\n\n\\(\\Rightarrow\\) Choice of an Integration Strategy:\n\nTop-to-bottom \\(\\Rightarrow\\) use stubs incrementally\nBottom-up \\(\\Rightarrow\\) use test drivers incrementally\n\n\n\n\nIntegration testing specific to OO\n\ntest initially individual classes\nsubsequently test interdependent classes: due to lack of a strict hierarchy, top-bottom / bottom-up not perfectly applicable \\(\\Rightarrow\\) scenario-based tests instead.\n\nHow are objects / classes interdependent?\n\ncommunication:\n\noperation calls\nusing attributes of the other class\nobjects / references to objects as input parameters to operations\n\nshared data: global variables\nshared (system) resources:\n\ncomposition / aggregation (initialization dependencies)\nshared namespace\n\ninheritance:\n\nCommon OO errors:\n\noperation is not available (configuration problems)\nincorrect object / operation called (during runtime binding)\ncrash / deadlock due to usage of shared resources (process, interface)\n\n\n\n\n\nStatic Testing\nagain,\n\nSoftware quality:\n\norganisational\n\nprogramming language\nconfiguration management\npair programming\nbug / error management\n\nconstructive:\n\nguidelines / templates\ntools\nmethods / notation\ntraining\n\nanalytical:\n\nstatic analysis: computers\ninspection: humans\ndynamic testing: execution using computers\n\n\n\n\nStatic Analysis\nstatic analysis:\n\ncompilers\nanalyzer / linters\n\nthings that can be enforced / checked / discovered:\n\nsyntax errors, as well as\n\ntype checking\nnot declared variables\nunreachable (dead) code\narray / field bounds\nconsistent usage of interfaces\n\ndeviation from conventions / standards\nconspicuous metrics\ncontrol-flow and data-flow anomalies\n\n\n\nMetrics\nthings like:\n\ndocuments (including code)\n\nquality\nvolume and scope:\n\nLOC (lines of code) \\(\\Rightarrow\\) complexity and error-proneness\nFan in / Fan-out:\n\nFan in: number of functions that call a function X. high Fan-in \\(\\Rightarrow\\) high coupling\nFan-out: number of functions that are called by X. high \\(\\Rightarrow\\) complex control logic\n\nBranching depth: high \\(\\Rightarrow\\) difficult to understand, error-prone\n\n\n\n\nOO Metrics\n\nComplexity of an operation: number of test cases necessary to achieve branching coverage\nComplexity of a class:\n\nnumber of operations (weighted with their respective complexities, see above)\ninheritance depth\nnumber of operations that overwrite the superclass version\n\nLow cohesion in a class: nu of op pairs that don’t use a common attribute - nu of op pairs that use a common attribute\ncoupling: external dependencies: fan-in / out w.r.t to operations\n\n\n\n\nInspection\nManual checking by humans of all sorts of documents (including code):\n\nnecessary, because many documents can be checked by computers like:\n\nlastenheft\npflichtenheft\nuser manual\n…\n\n\n\nInspection Methods\nvarious methods:\n\ndurchsicht\nstellungnahme\ntechnical review\nwalkhrough\ndesign & code inspections\n\nincreases in complexity and thoroughness.\nhow is a document reviewed:\n\nreading techniques:\n\nad-hoc\ncheck-list based:\n\ncan be derived from guidelines\n\nerror-class / type based (similar to check-list)\nperspective based (primarily for document other than program code) \\(\\Rightarrow\\) good for discovering semantic deficiencies: the reviewer reviews the doc from a specific perspective, and looks for the error regarding that perspective and a scenario\n\nPerspective:\n\nclient\ndeveloper\ntester\n\nScenario: use the document in a sepcific way, to achieve a specific task with the goal to discover erros.\n\n\n\n\nDurchsicht\n\nCarried out by one developer alone.\nAway from the screen, alone.\nShould be always done by the developer anyways, not redundant due to other inspection methods.\n\n\n\nStellungnahme\n\nThere is no manager, the author of the unit organizes and leads the review.\nAuthor is the manager and selects the reviewers.\ndocument is modified during the review without a protocol.\n\n\n\nTechnical Review\n\ngoal: find errors (not correct) and document them\ntest subject: any self-contained unit; method, module, class, document, etc\nrequired reference documents: specification, guidelines, question catalogue\nteam: (author does review)\n\nreviewers (gutachter): get specific tasks and types of errors that they should look out for\nmoderator: conducts / manages the review\nnotary: documents / writes down the protocoll\nauthor: one of the people who created the unit\nmanager: the boss who assigned the review task to the team (shouldn’t participate initially)\n\n\nmethod:\n\ninitiation: team is formed, members are assigned\npreparation: Reviewers read the doc and check it w.r.t. the tasks / points they were assigned\nreview session: reviewers present their findings, discuss, weigh and protocol them.\nresult: list of problems, errors and suggestions\n3rd round: Reviewers and author talk and discuss without a protocols.\nnacharbeit:\n\nrules:\n\n\nStructured Walkthrough\n\ncheaper version of the technical review\nauthor = moderator\nauthor presents their document stepwise\nreviewers ask prepared or spontaneous questions to discover problems\nproblems are documented / protocoled\n\ntypical for reviewing program code, albeit lower efficiency compared to the technical review.\n\n\nDesign & Code Inspection\nThe “noble” variant of the technical review with more formalities, but otherwise the same thing.\n\n\n\n\n\nAnalytical Quality Assurance at Large\nMethods from testing units can be applied to large systems as well:\n\nstatic analysis\nreviews\ndynamic tests\n\nbut with more planning and larger documents.\n\nMethod of Analytical QA\nmethod:\n\npanning \\(\\Rightarrow\\) resources, who carries out the activities?\n\ngoal: determine a testing strategy \\(\\Rightarrow\\) methods, expends w.r.t. costs / risks\n\ntest specification \\(\\Rightarrow\\) what, how, which methods?\ntest protocol, documentation of results $\nQA evaluation \\(\\Rightarrow\\) what is the state of the test object, does it satisfy the quality requirements, what should be done?\n\nuses metrics: coverage, error discovery rate\n\nQA management \\(\\Rightarrow\\) stability \\(\\Rightarrow\\) usually associated with continuous build.\n\nsoftware costs categories:\n\nnet production costs\nquality costs\n\nerror prevention costs (QA)\ntesting and correction costs (QA)\nerror costs\n\nerror searching costs (during development)\ntroubleshooting costs (during development)\nsubsequent costs of error in practice (in the field)\n\nreduction in usage of the product\n\nmaintenance costs\n\ngoal: reduce total costs\n\n\nPrinciples of Analytical QA\n\nComplete testing is not possible\nprogram testing ca be used to show presence of bugs, but not their absence\nTesting is not a late phase in software development, it should be done as early as possible \\(\\Rightarrow\\) reduces costs\nErrors / bugs are not distributed evenly in the system rather often occur in clusters. Presence of bugs \\(\\Rightarrow\\) other bugs in close proximity\nrepeating same tests doesn’t bring anything new\nBug-free system doesn’t mean that the system fulfills users expections \\(\\Rightarrow\\) Validation vs Verification."
  },
  {
    "objectID": "06/06.html",
    "href": "06/06.html",
    "title": "6  Evolution",
    "section": "",
    "text": "All activities that facilitate re-use and further development. (All activities that take place after the initial development phase)\ntopics:\n\nIntro\nArchitecture\nRe-use\nFurther development and change management\nDevOps & IT-Governance\nRe-engineering\n\n\nIntroduction\nAgain, core questions of SE:\n\nQuality: how to ensure that the software fulfills the requirements?\nUsers: How to ensure that software is useful?\nDevelopers: How to ensure that software is easy to understand, maintain and modify? \\(\\Leftarrow\\) this\nCosts / Time: How to ensure that the product will be ready within that given costs / time constraints?\n\ncore tasks of SE:\n\nDevelopment:\n\ndetermining the context of the software\nrequirements engineering\narchitecture\ndetailed design\nimplementation\nconfiguration management\n\nQuality Management:\n\nProduct: testing, inspection, metrics\nProcess: measurement, improvement, fine-tuning\n\nEvolution\n\noperation\nModification / further development\nre-use\nre-engineering\nchange management\n\nProject Management\n\nteam\ncosts\nappointments\nrisks\nclient / contractor relationship\n\n\nDefinition: all activities that support maintaining, further developing and reusing the product, and take place after the initial development phase:\n\nSoftware products are continuously developed and modified \\(\\Rightarrow\\) evolution.\nSoftware isn’t developed from 0 (no Greenfield development)\nCode should be easy to modify: Design patterns, architecture, reuse\nManagement of software development should and operation be oriented according to evolution:\n\nchange management\nDevOps and IT-Governance\n\nre-engineering: if the initial development of the software was bad, it could be necessary to improve it retrospectively.\n\n\n\nArchitecture\nDefinition:\n\ndescription of the fundamental organization of a system: components of a system, their relationship to each other and to the environment.\ndescription of design principles of a system\n\n\nElements / levels of architectural design:\n\nGoals\nExternal systems \\(\\Rightarrow\\) conceptual view\nComponents \\(\\Rightarrow\\) components view\nResources \\(\\Rightarrow\\) physical view\nProcesses \\(\\Rightarrow\\) runtime / process view\nOperational concept \\(\\Rightarrow\\) operational view\n\n\nArchitectural Design Goals\nThe architectural structure is defined in order to achieve and concretize certain QRs like:\n\nflexibility: configurability, maintainability, modifiability\noperational security: security and reliability (robustness), availability\nefficiency\n\nExample: Operation security:\n\nfirewall\nlayers\n\n\n\nExternal Systems\n\nExisting application software that neighbor and interact with the system \\(\\Rightarrow\\) Conceptional View (Configuration Diagrams)\nConceptional View \\(\\Rightarrow\\) Client, Users\n\n\n\nComponents\n\nComponents, interfaces, and inner structure: bundling and concretization of analysis classes, static QR (e.g. maintainability)\nComponent View: similar to class structure but units are larger and consist of other classes \\(\\Rightarrow\\) developers\n\n\n\nResources\n\nresources and the physical distribution of the components over the resources: dynamic QRs (efficiency, reliability, availability)\nresources: needed hardware and software\n\nhardware: computers (processors), network (communication), screens / terminals (I/O)\nsoftware: middleware (database), system software (operating system).\n\nrun-time view \\(\\Rightarrow\\) Client, Developer, Programmer\n\n\n\nProcesses\n\nprocesses represent the system during runtime, they have to coordinated: dynamic QRs\nruntime view \\(\\Rightarrow\\) Integrator, developer\nexamples:\n\njava threads\nbatch processes\ndialogue processes (reaction to user input)\n\n\n\n\nOperational Concept\n\ndescription of the edge-cases of system usage:\n\ninstalling, de-installing\nstarting the system, shutting the system off\nresource failure\ncomponent failure\n\noperational view \\(\\Rightarrow\\) client, operator.\n\n\n\n\nTasks of Architectural Design\n\nRefining and agreeing on architecture and design goals\nDefining architecture\nevaluating the architecture via prototypes & assessment\nIteration and modification of the architecture\n\n\n\nModeling Architecture\n\ncomponent structure\n\npackage diagram (purely logical structure of the system, usually code packages)\ncomposite structure diagram (static): how is a system structure and how are the components interrelated? \\(\\Rightarrow\\) UML component diagram.\ndynamic component diagram: which components are created at runtime and how are they interrelated?\n\nPhysical structure\n\ndistribution diagram \\(\\Rightarrow\\) UML distribution diagram\n\n\n\n\nArchitectural Patterns\nProven solutions to standard reoccurring architectural problems.\nThey are differentiated w.r.t. the view, each view can have it’s own solution, (the solutions can and do co-exist):\n\ncomponent view:\n\nLayered Architecture\nMVC\n\nphysical view (distribution patterns)\n\ncentral system\nclient / server: two-tier / three-tier\n\nrun-time view (control patterns):\n\nCentral control:\n\nCall-return\nMaster-slave\n\n\n\n\nComponent View Patterns\n\nLayers\n\nproblem / goals:\n\nsimple structure\nfunctions should abstracted / separated from one another\nfunction call only possible in one way\nparallel and sequential development of a systems components is possible\n\nsolution: layers and interfaces between layers\n\neach layer provides services to the layers above and use service from the above layers\n\nadvantages:\n\ndesign is simplified due to abstraction layers\nextensions are possible by introducing new layers\nimplementation of a layer can be easily substituted with a new one.\n\nshortcomings:\n\nlayered architecture is not always suitable\nnot easy to decide how to exactly structure layers\ntoo many layers \\(\\Rightarrow\\) inefficient.\n\nexamples: communication protocols, databases, operating systems.\n\n\n\nModel-View-Controller (MVC)\nMVC is a variant of the layered architecture:\n3 layers:\n\ncontroller: implements the business logic, processes the user input and the data\nview: presents the data to the user (gets the data from the model as an observer)\nmodel: contains the data\n\n\n\n\nPhysical Layer (Distribution View Patterns)\n\nCentral System\n\nproblem / goals:\n\nbusiness logic and data should at a central location\nonly authorized parties should have access\nall non-trivial processes happen at the central location\n\nsolution: central system and terminals accessing it\nexamples: classical mainframe applications, local pc applications\n\n\n\nClient/Server\nSimilar to central system, but some of the processing is done by the clients.\n\nproblems / goals:\n\ndata should be central\nnot all business logic is central, some of it relegated to the so-called clients.\n\nsolution: two-tier client/server architecture\n\nclient (front-end): short-lived process for a task\nserver (back-end): long-lived, persistent process (always runs on the background)\n\n\n\n\n\nRuntime View (Control Patterns)\n\nCentral Control - Call Return Pattern\n\nproblem / goals:\n\nwe want to control the calling of sub-programs\nalways exactly one sub-program is active\na central main program exists that controls the calls\n\nsolution:\n\nclassic workflow structure of procedural systems\nthe base is a constantly running main program\nmain program calls other sub-programs\nduring the execution of the sub-program the main program is still running (in idle mode)\nsub-programs can call other sub-programs\n\nadvantage: simple\nshortcomings:\n\nlow parallelization\nexceptions are difficult to handle\n\n\n\n\nCentral Control - Master / Slave\n\nproblem / goals:\n\nCentral periodic querying of state updates\nReaction to events via a central program\n\nsolution:\n\nA central infinite loop (master) for handling / reacting to events\nmaster checks for events or state updates \\(\\Rightarrow\\) carries out corresponding activities as a reaction\n\nadvantage: gut for constructing real-time systems\n\n\n\n\n\n\nReuse\nUsing existing software in new environments, e.g. Class library\n\ngoals:\n\nquality assurance: reused part is already tested\nreducing expenses\n\nproblems:\n\npsychology: Not Invented Here\nadaption costs (direct reuse is rarely possible)\n\nmethods for reuse:\n\nprocedures \\(\\Rightarrow\\) information hiding modules \\(\\Rightarrow\\) OOP / inheritance \\(\\Rightarrow\\) program generators \\(\\Rightarrow\\) frameworks \\(\\Rightarrow\\) patterns \\(\\Rightarrow\\) components \\(\\Rightarrow\\) product lines \\(\\Rightarrow\\) model driven architecture, service oriented architecture, microservices\n\n\n\nFrameworks\na collection of classes that represent an abstract solution to a family of problems\n\ngoals: reuse of code, architecture and design principles.\nreuse of behavioral pattern of a collection of classes\nhomogenous behavior of systems and implementations that use this framework to solve a family of problems\ndon’t call us, we call you: classes, their interrelationships, overall system structure and behavior is predefined \\(\\Rightarrow\\) adjustment in subclasses.\nadvantages:\n\npassing on expert knowledge\npredefined and well-thought-out design saves effort\nmaintenance effort is reduced\nwell suitable for systematic testing\nfacilitates integration and consistency of related requirements (that lead to the development of the framework in the first place)\ndifficulties / shortcomings:\n\ncreating frameworks is difficult\nunderstanding / getting accustomed with frameworks takes effort \\(\\Rightarrow\\) extra documentation\ncombining various frameworks is difficult.\n\n\n\n\n\nComponents (Component-Ware)\nThe ideal form of software development is the construction of software from predefined building blocks.\n\nComponents \\(\\Rightarrow\\) generic building blocks:\n\nadaptable\ncomposable\n\nsimple compositional mechanisms\n\ntools\ngraphical tools\n\ninfrastructure for component interaction: “object bus”\nexamples:\n\nJavaBeans,\nCORBA\nMicrosoft COM+\nWeb Services\n\n\nFeatures of components:\n\ninterfaces: explicitly defined interaction with other components and the environment\n\nclient components, server components\n\ncontext dependencies:\n\nrequired component infrastructure\nsystem resources\n\nindependent deployment: components are self-contained\ncomposition by third parties:\n\nShortcomings:\n\ncomponents are interoperable but only within the same technology, interoperability among different technologies is not possible\noften components are developed specific to a project,, thus the components become not reusable, only the infrastructure\n\n\n\nService Oriented Architecture (SOA)\nArchitecture consists of reusable, loosely coupled and fully interoperable business services:\n\nreusable: interface and implementation are separate\nloosely coupled: services are dynamically looked up and bound over a common enterprise infrastructure (enterprise service bus)\nfully interoperable: open standards, security, synchronous communication over a restful API (stateless)\nflexible: Business processes can be flexibly composed\ndescribes methods how applications are developed based on such an architecture.\n\n\n\nMicroservices\nSimilar to SOA, but not for the whole enterprise, rather on the level of individual applications. There is no shared infrastructure.\n\n\nCloud\n\nIaaS (Infrastructure as a Service): Hardware is provided on the cloud\nPaaS (Platform as a Service): Programming / Development on the cloud\nSaaS (Software as a Service): Software on the cloud\n\n\n\nProduct Lines\nCommon features and core assets shared over an iteration of products that target a similar market, and have similar goals.\n\n\n\nChange Management and Further Development\n\nSoftware has to be constantly developed further and maintained.\ntypes of changes\n\ncorrective\nadaptive\nimproving / preventive\n\nmethods:\n\ntraditional: try to predict the future changes and design software accordingly in advance (very generic, strongly modularized) \\(\\Rightarrow\\) difficult, costly\nagile: changes are difficult to predict \\(\\Rightarrow\\) lay out the process s.t. changes are easy to introduce (regression tests, re-factoring)\nsynthesis (risk management): estimate the costs and risks of serious changes; design the software with that in mind. For the rest use agile.\n\n\nSteps of change management:\n\npreparation: Verfolgbarkeit\nidentification of change requests. Consists of\n\noriginator:\naffected components:\nif the request originates based on an error \\(\\Rightarrow\\) reproducability of the error:\ndescription of the problem:\nwhat to do? :\nclassification of the severity of the problem:\nstatus of the change request:\n\nplaning of changes\ncarrying out changes\n\nProblems related to carrying out changes:\n\nhigh pressure for critical changes\nre-engineering has higher priority\nmissing documentation\nregression tests are not sufficiently supported\nintroduction of new errors\ntoo frequent changes\ngood tools are missing (configuration management)\n\n\nVerfolgbarkeit / Traceability\nThe ability to track the life of an element and describe it, both forward and backward\nvarious types:\n\nsingle level (e.g. traceability between requirements, i.e. only on the level of requirements)\nover various levels, e.g. requirements \\(\\Rightarrow\\) design \\(\\Rightarrow\\) code.\nvarious versions (evolutionary)\n\nproperties:\n\nimportant in safety-critical systems.\n\n\n\n\nDevOps & IT-Governance\nHow to organize this well? \\(\\Rightarrow\\) Development and Operations should be considered as closely related activities \\(\\Rightarrow\\) DevOps\nIT-Governance: Operation of Software + Hardware (encompasses DevOps)\n\nSoftware operation\nConsists of\n\nlaunch\nmaintenance\nchange / further dev\n\nlaunch:\n\ninstallation\ninstruction\nstart-up (especially prepping the initial data). Various types:\n\ndirectly changing to new software\nrunning new software initially parallel with the old: can be compared, higher safety, higher costs\ntest run (pilot installation, beta-test):\n\nnew software with old data, or\nstepwise adoption of parts of the new software (incrementally)\n\n\n\n\n\nDevOps\nAbove we defined what software operations entail (launch, maintenance, change / further dev). Earlier Development and Operation where separate department. Nowadays development and operations are considered together and done by the same department.\nDevOps principles:\n\neveryone is responsible for all aspects (development and operation)\neverything that can be automated should be automated: test, launch, support\ninitially measure, then change (DevOps processes and tools)\n\nDevOps automation &lt;=&gt; Code management system &lt;=&gt; DevOps Metrics / Measurements\nDevOps automation:\n\nCI (continuous integration): a change released on master \\(\\Rightarrow\\) updated, executable version of the system is generated and tested\nCDel (continuous delivery): after CI an operating / production environment is simulated and the software is tested there\nCDep (continuous deployment): after CDel the new version is installed / provided on the users-end\n\nIaC (infrastructure as code): configuration of the system needed for DevOps is in machine readable form (scripts) instead of manual processes. \\(\\Rightarrow\\) automation.\nDevOps metrics:\n\nMTTR (mean time to recover)\npercentage of failed deploymnets\ndeployment frequency\namount of customer complaints\npercentage increase of customers\n…\n\n\n\nIT-Governance\n\nIT-Technology (IT): entirety of a firms hardware and software\nIT-governance: management of IT, ensuring alignment with regulations, principles and goals.\n\n\n\n\nRe-engineering\nImproving the quality of the software without changing the functionality\nSteps:\n\nreverse engineering: Understanding of a system based on an incomplete documentation\nrestructuring (refactoring in agile): transformation of a structure to another one at the same level of abstraction, typically architecture level or design level.\nforward engineering: introducing the changes to the new structure (change management)\n\n\nReverse Engineering\nvarious models that can be derived with reverse engineering:\n\nreconstruction: derivation of system architecture\nre-specification: derivation of requirements from system behavior as a black-box.\nre-documentation: extending the documentation, e.g. generating a class diagram from a code-base.\n\n\n\nLegacy Systems\nlegacy system: old, large, important software.\nre-engineering is too costly, instead\n\nwrapping\nmigration: software is replaced incrementally\nre-development: functionality of the old software developed independently, then the old software is replaced."
  },
  {
    "objectID": "07/07.html",
    "href": "07/07.html",
    "title": "7  SWE Process & Project Management",
    "section": "",
    "text": "Making sure that the Software system is developed withing the time money constraints.\ntopics:\n\nProject management\nSWE-process models & methods\n\n\nIntro\nRelated core question: how ensure that the software system will be successfully developed using given resources (money, humans, technology) within the defined time and cost constraints?\n\nprocess: Abstract specification of the method and it’s structure that will be used to develop the software.\nproject: An instance of such a process\n\n\n\nProject Management\nThe application of knowledge, skills, tools, and techniques to activities contained in a project to achieve the project requirements.\ncontents of PM:\n\nappointments (milestones)\ncosts\nrisks\nparticipants:\n\nteam\nclient / contractor\n\nfunctionality\nquality\n\n\n\n\nmagical pentagon\n\n\nmagical pentagon:\n\nproject contents / function\nquality / effectivity\ncosts / efficiency\ntime / risks\nparticipants\nmethods / tools\n\nTask of project management:\n\nplanning\norganization\npersonnel development\nleadership / coordination\ncontrol\nmotivate and inform\n\nphases of project management:\n\nstart / initiate\nplan\ncontrol and execute \\(\\Rightarrow\\) feedback control loop\nclose\n\n\n\nSWE-Process models & methods\nFor every project there is an underlying process (process model)\nHow is process described:\n\nactors\nactivities\nresults\nguidelines\nboundary conditions\n\n\nProcess Models\nGeneral paradigms:\n\nwaterfall\nevolutionary / iterative / incremental development\nspiral\nV-model\nagile\n\nProcess models in practice\n\nV-Model XT\nXP, Scrum (Agile processes)\n\n\nWaterfall\nWaterfall model is Stepwise:\n\nrequirements analysis &lt;=&gt; functional spec &lt;=&gt; design &lt;=&gt; implementation &lt;=&gt; testing\n\nEvaluation:\n\nnot flexible: dependency on earlier steps\nlate testing\nlate implementation \\(\\Rightarrow\\) late validation / verification\nclear separation of tasks nd steps, low management effort\n\n\n\nEvolution / Iteration / Increment\n\nearly validation of requirements\n\nrapid prototyping: via a prototype\nevolutionary: prototype gets improved on\niterative: all of the steps are decomposed in small increments (from requirements to coding)\nincremental: step-wise further development of a core system\n\n\nEvaluation:\n\nearly QA via a prototype and early deployment (of a prototype)\nearly communication with users via prototype / early deployment\niteration is further development in small steps\niterations in small steps is good but not easy to determine the iteration steps in advance for large project\nFor rapid prototyping and evolutionary methods there is no clear project planning, therefore suitable only for smaller projects.\n\n\n\nSpiral Model\nThe Spiral Model is a risk-driven software development and project management approach that combines iterative development with systematic risk analysis. It consists of four key phases:\n\nPlanning – Define objectives, constraints, and alternatives.\n\nRisk Analysis – Identify and assess risks, and develop mitigation strategies.\n\nEngineering & Development – Build, test, and refine prototypes or system components.\n\nEvaluation & Review – Gather feedback, validate progress, and decide on next iterations.\n\nThis process repeats in cycles (spirals), gradually refining the system with each iteration. It is particularly useful for complex, high-risk projects requiring flexibility and continuous stakeholder involvement.\nEvaluation:\n\nearly QA due to risk analysis and testing\nearly communication with users via prototypes \\(\\Rightarrow\\) early validation / verification\nmany documents (danger of having too much documentation)\nhigh flexibility due to repetitive planning, goal and risk analysis\nhigh management effor \\(\\Rightarrow\\) suitable for large projects\n\n\n\nV-Modell\nA verification and validation-driven development model that expands the Waterfall model into a V-shaped structure. Each development phase (left side) has a corresponding testing phase (right side). It ensures early defect detection and is widely used in safety-critical systems (e.g., aerospace, automotive).\nThe phases and their corresponding tests:\n\nrequirements definition &lt;=&gt; acceptance test, system test\nrough design &lt;=&gt; system test, integration test\ndetailed design &lt;=&gt; integration test, module test\nmodule specification &lt;=&gt; module test\nprogramming (where the two branches meet)\n\nEvaluation:\n\nvery good QA due to early QA-planning and testing at each phase\nno prototyping, late implementation, no iterations like in waterfall\nearly QA planning simplifies QA management aspect of PM\nshould be used in conjunction with iterative methods\n\n\n\nV-Modell XT\nA German government standard for system and software development, refining the V-Modell with increased flexibility, modularity, and project tailoring. It emphasizes customization based on project needs and is commonly used in public sector and large-scale projects.\nEvaluation:\n\nearly QA-planning like V-Model and risk-analysis like spiral model\nif agile or incremental methods are applied then early validation with the users is possible\nVery beurocratic and documentation-heavy \\(\\Rightarrow\\) suitable only for large projects\nadaptability to different projects is good but high effort\n\n\n\nXP: An Agile Process\nAn agile software development methodology focusing on frequent releases, continuous feedback, and close collaboration. Key practices include\n\npair programming,\ntest-driven development (TDD),\ncontinuous integration,\ncontinuous customer involvement.\nIdeal for projects requiring rapid adaptability and high-quality code.\n\nKey features:\n\non-site customer\nshort increments\nplanning game \\(\\Rightarrow\\) user stories\nsimple design\nrefactoring\npair programming\nunit test\nCI/CD\ncoding standards\n\n\n\nScrum: Another Agile Process\nlightweight agile framework for managing complex projects through iterations (sprints). It features time-boxed cycles (2–4 weeks), daily stand-ups, backlog management, and defined roles (Scrum Master, Product Owner, Developers). Best suited for dynamic, fast-changing environments.\nprocess:\n\nclient requirements as story\nanalysis\nplanning\nimplementation / evaluation\nmetrics\n\nin short iterations.\nroles:\n\nProductOwner:\n\nrepresents client\ndefines vision of the software\ncreates user stories\nprioritizes requirements in the product backlog\n\nTeam: planning and results\nScrumMaster (not the same as ProjectManager)\n\nfacilitates productive environment for the team\ncommunication ProductOwner &lt;=&gt; Team\nmakes decisions\n\n\nartifacts:\n\nUser story: consts of cards, conversations and acceptance criteria\n\ncards: 1 sentence as a requirement “As user role X I want to do Y”\nconversation: all question necessary for understanding of the software\nacceptance criteria: description when a story is considered fully implmented?\n\nproduct backlog:\n\nlist of all user stories of current sprint\nuser stories are prioritized\n\n\nEvaluation of XP and Scrum:\n\nvery good QS-practices: acceptance test, Unit-test\nvery good user validation and user communication: onsite-customer (XP), ProductOwner (Scrum)\nfurhter development and maintenance not very well supported due to lack of documentation (XP very little documentation, Scrum user stories not very sufficient)\nadherence to the plan and complience with resources very good:\n\nXP: 40h week\nScrum: ScrumManager\n\ntoo little structure for large projects.\n\n\n\nNew Approaches: Continuous Software Engineering\nA modern software engineering approach emphasizing continuous integration, deployment, and delivery (CI/CD). Developers frequently commit changes, ensuring automated testing and deployment. This enables rapid, reliable software updates and is crucial for DevOps and cloud-native development."
  }
]
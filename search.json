[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Software Engineering Lecture Notes WS 24/25",
    "section": "",
    "text": "Preface\nLecture notes for the course “Software Engineering” at Heidelberg University WS24/25."
  },
  {
    "objectID": "intro.html#chapters",
    "href": "intro.html#chapters",
    "title": "1  Introduction",
    "section": "1.1 Chapters",
    "text": "1.1 Chapters\n\nIntroduction\nCommunication in a Project link\nRequirements Engineering (Communication with the Users) link\nDesign (Communication with Developers) link\nQuality Management link\nEvolution link\nSWE-Process (Summary and Project Management) link"
  },
  {
    "objectID": "02/02.html",
    "href": "02/02.html",
    "title": "2  Communication in a Project",
    "section": "",
    "text": "Following topics relate to and determine communication within a project:\n\nNumber of participants and their roles in the project\nType of the contractual relationship\nTeam Organization: The way developers communicate within the project\nCollaborative Coding\n\n\nProjects and Participants\nterms relating to project and process:\n\nprocess:\nproject\nprocess model:\n\ncharacteristics of a project:\n\nlimited time\ncreator\npurpose\nclient\nresults\nmeans and tools\norganization and planning\n\nparticipants:\n\nclient\nuser\nmanufacturer\n\n\n\nContractual Relationship\nproject types:\n\nEP (Entwicklungsprojekt) -&gt; development project\nAP (Auftragsprojekt) -&gt; Commissioned Project\nEDP (EDV-Projekt, EDV = Elektronische Datenverarbeitung) -&gt; IT Project\nSP (Systemprojekt) -&gt; System Project\n\n\n\nTeam Organization\ntypes of team organization:\n\nsingle person\n2-person team\nanarchic team\ndemocratic team\nhierarchical team\nchief-programmer team\nagile team\n\ntypes of secondary organization:\n\nfunctional\nproject-based\nmatrix\n\n\n\nCollaborative Coding\n\nPair programming\nDistributed development"
  },
  {
    "objectID": "03/03.html",
    "href": "03/03.html",
    "title": "3  Requirements Engineering",
    "section": "",
    "text": "requirements engineering can be understood as corresponding to the communication with the users / clients. Deals with the following topics\n\nIntroduction to communication with users/clients.\n\nClients and Requirements\nDescription and specification of requirements\nDefining Requirements Engineering\nOutcome of Requirements Engineering\nBenefit of specification\nComplexities of RE\n\nUsage modelling / description\n\nIntroductory Example\nIntroduction\nTasks, Roles, Persona\nDomain Data\nFunctions, UI-Structure\nGUI\n\nDocumentation Quality\n\nIntroduction and Templates\nCharacteristics and style guide\n\nUsability\nQuality assurance with the client\n\nacceptance test\nusability test\n\nQuality requirements\n\nMotivation\nQuality attributes\nQR-description\nQR-test\n\nUse-cases (not relevant to the exam)\n\nDescription of Uses Cases\nUse for system testing\n\nRE procedure\n\nIntroduction\nGathering requirements\nSpecificying requirements\n\n\n\nCommunication with Users / Clients\n\nrequirements engineering:\n\ncollection of the requirements from the client\nspecification / formalization of the requirements\ntesting / examination of the requirements\nmanagement of the requirements\n\nrequirements engineering result:\n\ndocument:\n\ndescription using system functions\n\nprototype\n\nAdvantages and Uses of Specification:\nDisadvantages of a missing specification\nDifficulties related to RE:\n\n\n\nUsage Modelling\n\nTask-oriented Requirements Engineering:\n\nTask level: tasks, roles, persona\nDomain level: subtasks (as-is & to-be), domain data\ninteraction level: system functions, ui-structure\nsystem level: gui, screen-structure (virtual window)\n\n\nRoles, Persona, Tasks\n\nRoles, Persona\nUDC (User-centered design)\nRoles and Persona\n\nUser role:\nUser profile:\n\nHow are personae described:\n\nname\nbiographic facts: age, gender, etc\nknowledge and attitude with respect to the tasks and technology:\nneeds: main use-cases in which the user wants to apply the software -&gt; Tasks\nfrustrations:\nideal features:\n\n\n\nTasks\nHow tasks are described:\n\nGoals\nDecisions\nCauses\nPriority\nExecution profile (frequency, continuity, complexity)\nPrecondition\nInfo-in (input)\nInfo-out (output)\nresources (means, participating roles)\n\nsub-tasks:\nPersona-task correspondence:\n\nneeds &lt;=&gt; sub-tasks =&gt; combination of system-functions\nfrustrations &lt;=&gt; problems in sub-tasks\nideal features &lt;=&gt; ideas, system functions\n\n\n\nDomain Data\nDomain data explain the terms used in the task descriptions.\nGoal: describe/model the entities of real world, including their relationships / associations to each other, in order to understand the tasks.\n\ndomain data describe entities that are relevant within the context of the sofwtare. They correspond to the terms used in the task description =&gt; independent from the software.\ndescribed with simple class diagrams =&gt; domain data diagram (no operations, no aggregation, no inheritence, only associations)\nsometimes glossary is sufficient.\n\nsometimes not sufficient, because there additional data necessary on the UI level =&gt; interaction data. (not relevant in our MMAP case)\n\n\nFunctions & UI-Structure (Interaction Level)\nGoal: implementation of the User/Machine boundary with respect to the task descriptions.\nconsists of 2 parts:\n\nSystem functions: which functions are provided by the system?\nUI-Structure:\n\nin which context can the user call which functions,\nwhich data is available/visible in those contexts?\nhow are functionalities divided among the sub-parts?\n\n\n\n\n\n\n\n\nWarning\n\n\n\nUI-Structure is not GUI-structure, i.e. the concrete layout is not yet determined.\n\n\n\nSystem Functions\nhow is a system function described:\n\nname: nomenclature verb-object, describe what will be achieved on the user data (e.g. unlinkMovie =&gt; movie will be unlinked)\ninput:\n\ncontext (i.e. workspace) in which the SF accessible\n\nconcrete input: data that is gathered during the interaction with the user. Such data is not yet determined when the SF is first called on the GUI, but first provided by the user during the interaction.\noutput: changes of the UI\ndescription:\nexceptions: cancel/discard by the user\nrules:\nquality requirements:\nprecondition:\npostcondition:\n\n\n\nUI-Structure\nConsists of\n\nworkspaces:\n\nbundle related system functions and data similar to a class (but only from an abstract user point of view. Actual structure in code can be completely different)\nonly system functions that can be triggered by the user are listed\n\nnavigation links between workspaces\n\nUI-structure abstracts from a concrete screen-layout. Logical represents a logical view of the interaction structure.\n\n\n\n\n\n\nImportant\n\n\n\nUI-structure is created concurrently with the System functions, because their close interrelation. (Workspaces contain System functions and data)\n\n\n\n\n\nDesign of System Functions and UI-Structure\n\nhow is the system function specification template filled in?\nhow are ui-structure decision made concurrently to SF specifications?\ninitial test considerations?\n\nThere’s still lots of wiggle room for specific design decisions.\nTODO:\n\n\nGUI\nGUI= concrete layout of the UI:\n\ndata representation\nfunction representation\nwindow structure\ndialogue description (how user controls the execution of functions)\n\nDesign principles:\n\nlaw of proximity\nlaw of closure\nlaw of good continuation\nlaw of similarity\n\nTypes of functions:\n\nsemantic functions: actual data manipulation in the system, e.g. save, open, calculate something etc\nhelp functions / auxillary functions: data manipulation on the screen, e.g. text size\nsearch\nnavigation\n\nHow functions are represented:\n\nbuttons\ncheckbox\nmenu-selection\nshortcut\nicon\nscroll-bar\ndrag-and-drop\n\nViews (Window / Screen): concrete version of Workspaces:\n\nhow is data represented\nhow are functions made available / represented\n\nDocumentation of a view: Virtual Window (Mock-up)\n\n\n\nDocumentation Quality\nfollowing topics relate to it:\n\ndocument templates\nfeatures and sytle-guide\n\nmany documents exist:\n\nSoftware context-design:\n\nproblem-description\ncontract\nacceptance test plan\n\nRequirements Engineering:\n\nClient-requirements\nUsage test plan\nSoftware specification\nSystem test plan\n\narchitectural specification:\n\narchitectural specification / definition\nsub-system specification\n\nDetailed design:\n\ncomponent specification\nintegration test plan\n\nImplementation:\n\nCode\nComponent test plan\n\n\nCommunication happens via / is facilitated by documents\n\n\nUsability\nThe degree to which a product can be used efficiently and adequately for specific tasks / goals, in a specific usage context:\n\neffectivity\nefficiency\nsatisfaction\n\n7 interaction (dialogue) principles :\n\nTask appropriateness: no unnecessary repetitive actions must be taken bythe user\nSelf-descriptiveness: user knows what the actions achieve, what’s the input, output and the systems response.\nControllability: user can decide the order of the operations, can terminate the operation and resume at any given moment without loss.\nExpectation-conformity: system is consistent, confirms to users real-life experience and other software conventions\nError tolerance: even at the hands of an incorrect input the intended result can be achieved with minimum correction effort.\nUser engagement: system must be appealing and inviting and provide users a positive experience.\nLearnability: users are supported and guided during the learning of the software\n\n\n\nQuality Assurance with the Clients\n\nverification: whether the software being built confirms to the specifications derived from the requirements and whether the requierements documents meet quality standards\nvalidation: whether the specifications actually correspond to clients requirements \\(\\Rightarrow\\):\n\nusability test\nacceptance test\n\n\n\nAcceptance Test\n\nTests whether the client accepts the system \\(\\Rightarrow\\) validation.\nUses system tests provided by the client\nincludes particularly also usability tests.\ntests are carried out in the production environment (live system where the software is fully deployed and used by the clients)\n\n\n\nUsability Test\nA representative group of users from the target demographic of the product take part in the test to determine to what extent the usability criteria is met.\nConsists of:\n\nusers\nobservers\n\nhow:\n\ndevelop a test plan:\n\ngoal\ndescription of the problem\ndescription of the users\ntest design\nlist of tasks\ntest environment\nevaluation criteria\n\nprepare the test:\n\nrecruiting a representative group\nrecruiting observers\ndistribution and review of the test plan with the participants\nprepare scenarios\nprepare surveys: backgroung, pretest, posttest\nprepare test env\n\nexecute the test:\nanalyse the results\n\n\n\n\nQuality requirements\n\nMotivation\n\nfunctional requirements \\(\\Rightarrow\\) what?\n\ntasks\nsystem functions\ngui\n\nnon-functional requirements (NFR) \\(\\Rightarrow\\) how good?\n\nQuality of the system\n\nQR = quality requirements: describe product considerations\nQA = quality attributes\n\n\n\nQuality Attributes\nQA describe various types of software quality.\nCategories:\n\nQuality in Use: Direct validation with the users\n\nBeneficialness: how well are users supported\n\nusability\naccessibility\nsuitability\n\nfreedom from risk: general impact\nacceptability (how good is the system from the point of view of the user)\n\nsupport experience\ntrustworthiness\ncompliance (regulations, laws)\n\n\nSoftware Product Quality: verification (internally), validation (externally), continuously during the whole development process\n\nfunctional stability\n\nfunctional completeness\nfunctional correctness\nfunctional appropriateness (helpful)\n\nperformance efficiency\n\ntime behavior\nresource utilization\ncapacity\n\ncompatibility\n\nco-existence with other software\ninteroperability\n\ninteraction capability (usability)\n\nrecognizability\nlearnability\noperability\nuser error protection\nuser engagement\ninclusivity\nuser assistance\n\nreliability\n\nfaultlessness\navailability\nfault tolerance\nrecoverability\n\nsecurity\n\nconfidentiality\nintegrity\nnon-repudiation\naccountability\nauthenticity\n\nmaintainability\n\nmodularity\nreusability\nanalysability\nmodifiability\ntestability\n\nflexibility\n\nadaptability\nscalability\ninstallability\nreplaceability\n\nsafety\n\noperational constraint\nrisk identification\nfail safe\nhazard warning\nsafe integration\n\n\n\n\n\nDescribing QR\n\nQR should be made as measurable and as concrete as possible.\nQR are defined in parallel with the FR with as much detail as possible, for all levels:\n\nTasks\nDomain data\nFunctions\nGUI\n\n\n\n\nTesting QR\n\nDifferent QA categories require different testing methods.\nUsually only possible at the level of system testing, especially acceptance testing.\nUsually conducted by acting out scenarios\n\n\n\n\nUse Cases\nSo far we described the requirements via:\n\n(Sub)-Tasks\nDomain Data\nRoles / Persona\nSystem functions\nInteraction data\nUI Structure\n\nAt the system level this is further refined via:\n\nconcrete views\ninteraction models\n\nBut this is only an indirect description of users interaction with the system.\nUse Cases describe the specifics of users interactions with the system, specifically the particular execution sequence of system function to complete a certain (sub-)task. Thus, they are derived from Tasks\nuse cases vs TORE:\n\nuse cases cover only a subset of TORE. Particularly\n\nNo domain data model\nNo UI-Structure (which SF & Data are available in which view, how do you navigate between views)\n\nUC integrate SF within the execution flow, in TORE SF are contained in the subtask description (although without the execution flow)\n\n\nDescription of a UC\nExample: manage movie or performer ratings in MMAPP.\n\nName: Manage Rating\nActor: Person\nGoal: to rate movies or performers\nPrecondition: at least one movie exists. Depending on the current state wither A1 or A2 is the starting point:\n\nFlow of events:\n\nActor: A1) W0.1 Movie Master View … System: System shows the\n…\n\nRules:\nQuality requirements:\nData, System Functions:\nPostcondition:\n\n\n\n\nUse of System Tests\nScenario vs UC:\n\nScenario: a specific interaction flow\nUC: an abstract description of a set of scenarios\n\nA choice of a typical set of scenarios can be used as a template when creating a UC. On the other hand a UC can be validated by a subsequent creation of a set of test scenarios.\nWhat is a typical flow?\n\nnormal flow\ncoverage of branches / exceptions\ndealing with large input (stress test)\ndealing with complex execution flows (many functions are called)\n\n\n\n\nRE Procedure - Method of RE\nSo far we only concerned ourselves with describing the requirements. Here we explain how to gather and manage them.\n\nIntroduction\nStakeholder (client) requirements: the requirements stipulated by the client to achieve a certain goal or solve a certain problem.\n\nrequirements are gathered\nrequirements are formulated / formalized in the specification\nspecifications are validated and verified\nspecifications are translated into a design\nthe design is implemented\nthe implementation is tested\nthe implementation is deployed to the clients\n\n\n\nGathering Requirements\nwhat information should be gathered:\n\nprevious method to solve the problem\nproblems related to the previous method\ngoals for the new system / method to solve the problem\nsuccess criteria\nrough system architecture (how many components, distribution)\nrealistic solutions\nconsequences and risks\n\nhow it is gathered:\n\nobservation\nuser surveying\nethnographic studies\nuse cases\nworkshops\nobject oriented analysis\nentity relationship diagrams\nconceptual modelling\ndata flow diagram\nformal specification\nprototypes\nobservations of other products\nliterature research\nstudying standard software\n\nrequirements can also be gathered via user feedback\n\n\nSpecifying Requirements\ncontents and types of requirement specification:\n\nfunctional requirements: how should the software support the users?\nnon-functional requirements:\n\nquality requirements: how well should the software support the users?\nedge conditions\n\nrationales: reasoning behind the decisions?\n\nrequirement specification is textual as well as schematic (UML, ER etc)\nThere are two types of requirements:\n\nclient (user) requirements\nsystem (developer) requirements: requirements from the point of view of the developer with more technical detail.\n\nUsually two different documents are created.\nTORE again:\n\ntask level:\n\ntasks\nroles, persona\n\ndomain level:\n\nsub-tasks\ndomain data\n\ninteraction level:\n\nsystem functions\ninteraction\nui-structure\n\nsystem-level: GUI\n\nscreen-structure (virtual window)\n\n\nabove levels can be categorized as follows:\n\n1, 2: client requirements\n3, 4: system requirements\n\nTwo different specification documents:\n\nlastenheft (client specification document)\npflichtenheft (developer specification document)"
  },
  {
    "objectID": "04/04.html",
    "href": "04/04.html",
    "title": "4  Design",
    "section": "",
    "text": "Design can be understood as communication with and within the developers.\nGoal: The software system can be further developed efficiently, and is easy to understand for new developers.\nBelongs to the development and specifically detailed design category of software development.\nDeals with the following topics:\n\nIntroduction to Modelling\nClass diagrams\nInteraction diagrams (sequence diagrams)\nState Diagrams\n\nUML State diagrams\nDialog models\n\nClass design with OOAD\n\nOOAD introduction\nOOAD: Analysis Class diagram\nOOAD: Design Class Diagram\n\nDesign Patterns\n\nIntroduction\nCreational patterns\nStructural patterns\nBehavioral patterns\n\nRationales (Communication of decisions)\nSummary of modelling techniques\n\n\nIntroduction to Modelling\nA given team (approx 7 people) developes an understanding of the structure of the Software System, albeit without using code, since code is too detailed and is not conducive to understanding the overall structure of the software.\nInstead an appropriate abstraction level is necessary \\(\\Rightarrow\\) modelling languages.\nModel: Abstraction of a system, expressed in a formal language / notation where irrelevant details are omitted.\nCharacteristics of models:\n\nmapping\nincompleteness\npragmatic (a model is created with a certain purpose / goal)\n\nCharacteristics of a formal notation:\n\nsyntax\nsemantics\npragmatics\n\nanalysis techniques: type checking, consistency checks\nsimulation techniques\ntransformation techniques (refactoring, (algebraic) simplification)\ngeneration techniques\n\n\nA notation is a ‘theory’ that enables to reason about and manipulate representations of objects from the domain.\n\nUML\ndefines:\n\nStructure diagrams \\(\\rightarrow\\) statics of the system\nBehavior diagrams \\(\\rightarrow\\) dynamics of the system\n\ninteractions\nflows\nstate transitions\n\n\n\nStructure Diagrams\n\nDesign:\n\nClass Diagram (analysis and design)\nObject diagram (special cases)\npackage diagram (bundles of classes)\n\nArchitecture:\n\ncompositional structure diagram\nlogical component diagram (internal and external view)\ndistribution diagram (over the physical components)\n\n\n\n\nBehavior Diagrams\n\nFlows:\n\nUse case diagram (overview of the use case)\nactivity diagram (sequences of activities)\nstate diagram (sequences of states)\n\ninteraction:\n\nsequence diagram (sequence of messages)\ncommunication diagram (focus on a component)\ntime diagram (communication between automata)\ninteraction overview diagram (interaction of multiple interactions)\n\n\nIn the lecture especially:\n\nclass diagrams\nobject diagrams\ninteraction diagrams\nstate diagrams\n\n\n\n\n\nClass Diagrams\nimportant components of class diagrams:\n\nclasses (objects)\nassociations between classes:\n\naggregation\nkomposition\n\nattributes\noperations\ngeneralization / specialization relationship (inheritance)\ninterfaces: a view on a class (a contract)\n\n\n\nInteraction Diagrams (Sequence Diagrams)\ninteraction diagrams describe communication between various actors.\nVarious uml interaction diagrams:\n\nsequence diagrams\ncommunication diagrams\ntime diagram\ninteraction overview diagram\n\n\n\n\nseq diag\n\n\n\n\nState Diagrams\n\n\nClass Design with OOAD\nSteps of the software process:\n\nanalysis and specification: gathering and representing requirements\ndesign: structure and architecture of the software is defined\ncoding: implementation of the end product in detail.\n\nDesign has the following goals:\n\npartitioning the system into manageable units\nlaying out a structure: relationship between the units / parts that make up the whole system\nhierarchical partitioning: abstraction that helps understand and maintain a large software system\n\nresults from requirements:\n\nDomain / Interaction data diagram: specification of the data in detail\nSFs or UCs: specification of functionality / how functionality is carried out\nWorkspaces (UI-Structure): How and where is the data & SF represented and provided for the user, as well as the navigation between the workspaces.\nView (Virtual Window): the mockup of the GUI\n\nConsideration when making design decisions:\n\nData management classes: implementation of domain / interaction data diagram\n\nwhich data which classes?\ncan some entities be directly taken as classes?\nwhat operations are necessary?\nhow is data storage implemented?\n\nClasses for internal processing: Implementation of SFs\n\nhow are SFs implemented / distributed among operations of which classes? (note that SFs do not generally correspond to individual operations, but are combinations of multiple ops)\n\nUI classes: Implement the views (virtual windows) and the navigation from the UI-structure.\n\n\nDesign Principles: Cohesion and Coupling\n\nCohesion\nA measure of or degree to how much the elements of a component belong together.\nGoal: high cohesion, i.e. elements within a module or component belong together strongly, are highly interdependent \\(\\Rightarrow\\) good for maintenance.\nWe can’t easily partition a highly cohesive module into subparts, where the subparts are independent of each other.\nHow to achieve high cohesion:\n\nprinciples of object orientation (data encapsulation)\nusing appropriate design patterns for coupling and decoupling\n\n\n\nCoupling\nA measure of the degree of how strongly different components depend on one another.\nGoal: low coupling, i.e. low interdependence between different components\nLow coupling is good for performance (communication is simpler)\nhow to reduce coupling:\n\ninterface coupling: information exchange takes place only via interfaces.\ncomponents should call other components as little as possible\ndata coupling should be avoided: no shared data among different components\nstructure coupling should avoided: no shared structure among different components\n\nSimple and complex operations:\n\nSimple operation: only direct access of attributes (class access it’s own attributues)\nComplex operation: direct as well as indirect access of attributes (indirect access: class A access attributes of class B)\n\nincrease coupling\nhinder cohesion\n\n\nComplex operations should therefore be split up in smaller operations, or encapsulated in own class whose data they access.\n\n\n\nOOAD\nObject-oriented analysis & design \\(\\Rightarrow\\) systematic development of the design model\nthe process of: requirements \\(\\Rightarrow\\) class diagram:\n\nwhat decision should be made and how?\nwhat classes are needed, with what operations and attributes should the classes be equipped?\n\nOOAD 2 step method:\n\nAnalysis class model: defines class structure based on the requirements\nDesign class model: concrete implementation of the analysis class model using frameworks, libraries and concrete classes, taking design goals, especially NFRs.\n\n\nAnalysis Class Model / Diagram\n4 Steps:\n\nDetermine classes, attributes, and association from the requirements, with appropriate names.\nDetermine the operations of the classes: distribute basic operations and SFs as methods (operations) in classes, taking high cohesion and low coupling into account.\nDetermine complex associations and inheritance relationships\nConsolidate the class diagram: possibly dissolve interaction / ui classes, consolidate associations.\n\n3 types of classes:\n\nentity class: describes objects with permanent existence\n\ne.g.: film, actor.\n\ncontrol class: describes processes. SFs are initially modelled as such. Serve as placeholder for complex operations, ultimately are dissolved and distributed as methods among various appropriate classes\nboundary / interaction / dialogue class: bundles data and operations that are provided on the UI.\n\n\nStep 1\nGoal: Determine / derive classes from the requirements\nRules:\n\nEntity classes:\n\nEntities from the data diagram become entity classes, e.g. film and actor.\nassociations from the data diagram become the associates between the classes\n\nControl classes:\n\nSF are initially modelled as such\ncontrol classes are linked to the entity classes, whose attributes they access\ncontrol classes are linked to other control classes, which they cooperate with.\n\nBoundary classes:\n\nWorkspaces \\(\\Rightarrow\\) boundary classes\nare linked to the entity classes, that are displayed in the workspace\nare linked to the control classes of the SFs that are provided on the UI interface.\nnavigation between workspaces \\(\\Rightarrow\\) links / associations between boundary classes.\n\n\n\n\nStep 2\nGoal: Determine the operations of the classes, dissolve control classes by distributing them among the various classes as methods. (occasionally a control class can be retained as a concrete class)\nRules:\n\nDissolve control classes by distributing them among entity and dialogue classes:\ncanonical solution: if control class operates only on the attributes of a single class, it becomes a method in that class.\nsimple solution: if multiple classes are involved, but the input and output are associated to one class respectively, then the the control class can be … ?\ncomplex solution: if multiple classes are involved, and the output and input relate to multiple classes, then … ? \\(\\Rightarrow\\) sometimes objectification of the control class\nOperations can be split up or united, depending on the situation.\n\nan operation can cover multiple SFs (only for the canonical solution)\nSFs can be implemented by multiple operations\n\n\n\n\nStep 3\nGoal: Use inheritance and model complex associations\n\n\nStep 4\nConsolidate the model and possibly dissolve the interaction classes\nRules:\n\nplace interaction (ui) classes in a separate layer (e.g GUI layer)\nalternatively assign dialogue classes to some other classes: in this case the class is responsible both for data and representation on the GUI\nrevising the associations: cover all possible communication links\n\neach class that has a complex operation must be associated to the classes that they call\nconsolidate the associations\nprovide multiplicities (cardinalities)\n\nno redundant links: associations that are not used in any SF should be removed.\n\n\n\n\nDesign Class Diagram / Model\nGoal: preparation for coding by taking design goals into account.\nAnalysis class diagram gets refined with infrastructure classes (e.g. library) and completed, often using design patterns.\nSteps:\n\ncomplete the list of attributes and operations\ndetermine the data types and access specifiers (private, protected, public, etc)\nspecify operations (pre- and postconditions)\ndefine exceptions\nspecify concrete data structures that realize associations\neliminate multiple inheritance\n\n\n\n\n\nDesign Patterns\n\n\nRationales (Communication of Decisions)\nDocuments contain only the last decision. Communication of all sorts of decisions and history of discarded decisions via Rationales.\nHow are rationales described:\n\nquestions: concrete problems that don’t have an obvious solution\noptions: describe alternative solutions to a problem\ncriteria: quality requirements\narguments: condensate and summarize discussions\ndecisions:\n\nrelates to one or more open questions\nsummarizes the chosen options and arguments that support it"
  },
  {
    "objectID": "05/05.html",
    "href": "05/05.html",
    "title": "5  Quality Assurance",
    "section": "",
    "text": "Quality: Software satisfies the requirements\ntopics:\n\nIntroduction\nOrganizational quality assurance\nTesting:\n\nIntro\nTest-case specification\nBlack-box component testing\nWhite-box component testing\nSystem testing\nIntegration testing / overall-component testing\n\nStatic testing\n\nStatic Analysis\nMetrics\nInspection\n\nAnalytical Quality assurance at large"
  },
  {
    "objectID": "06/06.html",
    "href": "06/06.html",
    "title": "6  Evolution",
    "section": "",
    "text": "All activities that facilitate re-use and further development. (All activities that take place after the initial development phase)\ntopics:\n\nIntro\nArchitecture\nRe-use\nFurther development and change management\nDevOps & IT-Governence\nRe-engineering"
  },
  {
    "objectID": "07/07.html",
    "href": "07/07.html",
    "title": "7  SWE Process & Project Management",
    "section": "",
    "text": "Making sure that the Software system is developed withing the time money constraints.\ntopics:\n\nProject management\nSWE-process models & methods"
  }
]